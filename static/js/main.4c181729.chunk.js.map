{"version":3,"sources":["util/assert.ts","model/Types.ts","model/MazeData.ts","model/Coordinates.ts","model/Vector.ts","model/Ways.ts","model/changeDirectionToOpposite.ts","model/getTileDistance.ts","model/chooseNextTile.ts","model/getDirectionFromTileToTile.ts","model/GhostStateChart.ts","model/TimeoutTimer.ts","model/updateGhostStatePhase.ts","resources/sfx/ghost_dead.mp3","model/getSoundPlay.ts","model/Ghost.ts","model/findWayPoints.ts","model/makeGhosts.ts","model/Maze.ts","model/PacManStateChart.ts","resources/sfx/die.mp3","model/PacMan.ts","model/Game.ts","model/DebugState.ts","model/Store.ts","components/StoreContext.ts","model/collisionDetection.ts","resources/sfx/eat-fruit.mp3","model/eatEnergizer.ts","resources/sfx/pacman_eat.wav","model/detectCollisions.ts","model/chooseNewTargetTile.ts","model/updateGhosts.ts","model/pacManDyingPhase.ts","model/movePacManBy.ts","model/updatePacMan.ts","model/onAnimationFrame.ts","model/updateExternalTimeStamp.ts","model/updateGameTimestamp.ts","model/updateEnergizerTimer.ts","model/useGameLoop.ts","model/useAnimationLoop.ts","pages/GamePage/components/RestartView.tsx","pages/GamePage/components/Score.tsx","pages/GamePage/components/PauseView.tsx","components/Spacer.tsx","components/Board.tsx","components/Sprite.tsx","pages/GamePage/components/MazeView.tsx","components/Box.tsx","pages/GamePage/components/PillsView.tsx","pages/GamePage/components/PacManView.tsx","pages/WayFindingPage/WayPoint.tsx","pages/WayFindingPage/WayPoints.tsx","pages/GamePage/components/Target.tsx","pages/GamePage/components/GhostsView.tsx","pages/GamePage/components/Message.tsx","pages/GamePage/components/GameOver.tsx","pages/GamePage/components/ExtraLives.tsx","model/useEventListener.ts","pages/GamePage/components/LevelView.tsx","model/useOnClickOutside.ts","components/SoundOff.tsx","components/SoundOn.tsx","pages/GamePage/components/SoundView.tsx","pages/GamePage/components/GameBoard.tsx","model/useScaleElement.ts","resources/sfx/ready.mp3","pages/GamePage/components/StartSound.tsx","pages/GamePage/GamePage.tsx","pages/GamePage/components/useKeyboardActions.ts","App.tsx","index.tsx"],"names":["assert","condition","msg","Error","Directions","assertValidDirection","direction","includes","BASIC_PILL_ID","getLayer","layerName","layer","MapData","layers","find","name","pillsLayer","waysLayer","MAZE_WIDTH_IN_TILES","width","MAZE_HEIGHT_IN_TILES","height","getTileMatrix","data","tileMatrix","Array","dataIndex","ty","tx","tileId","waysMatrix","SCALE_FACTOR","SCREEN_TILE_SIZE","SPRITE_TILE_SIZE","SCREEN_TILE_CENTER","SCREEN_TILE_CENTER_VECTOR","x","y","MAZE_WIDTH_IN_SCREEN_COORDINATES","MAZE_HEIGHT_IN_SCREEN_COORDINATES","MAZE_DIMENSIONS_IN_TILES","isTxValid","isTyValid","isValidTileCoordinates","tile","assertValidTileCoordinates","screenFromTileCoordinate","tileCoordinate","tileFromScreenCoordinate","screenCoordinate","Math","floor","screenFromTile","tileFromScreen","screen","addCoordinatesAndVector","coordinates","vector","rectangleContainsTile","tileRectangle","tile1","tile2","wrapTileToBounds","bounds","multiplyVector","factor","BOX_TILE_COORDINATES","BOX_SPACE_TILE_COORDINATES","isWayFreeAt","isTileCenter","DIRECTION_TO_VECTOR","RIGHT","LEFT","UP","DOWN","directionToVector","distance","moveFromTile","steps","step","newTile","DIRECTION_TO_OPPOSITE_DIRECTION","isWayFreeInDirection","stepSize","nextTile","getNextTile","DIRECTION_TO_TILE_VECTOR","scaledVector","movedTile","changeDirectionToOpposite","ghost","getTileDistance","neighbourTile","targetTile","dx","abs","dy","sqrt","pow","chooseNextTile","currentTile","currentDirection","boxDoorIsOpen","toJS","bestNextTile","chooseBestNextTile","anyNextTile","chooseAnyNextTile","console","error","JSON","stringify","candidates","possibleNextTile","distanceToTarget","push","bestCandidate","minBy","neighbourTileInCurrentDirection","tileCoordinates","isWayFreeForGhostAt","TUNNEL_X_RIGHT","getDirectionFromTileToTile","tileFrom","tileTo","isEqual","INITIAL_GHOST_STATE","GhostStateChart","Machine","id","initial","on","RESET","states","chase","ENERGIZER_EATEN","PHASE_END","target","actions","COLLISION_WITH_PAC_MAN","scatter","frightened","ENERGIZER_TIMED_OUT","dead","REVIVED","TimeoutTimer","action","bound","duration","onTimedOut","this","running","timeSpent","timePassed","isTimedOut","stop","start","observable","computed","updateGhostStatePhaseTime","statePhaseTimer","advance","game","lastFrameLength","updateGhostStatePhase","atTileCenter","send","setDuration","getStatePhaseLength","state","restart","getSoundPlay","url","volume","gameStarted","isMuted","sound","Audio","play","KILL_GHOST_SCORE","Ghost","ref","stateChart","eventHandler","extended","withConfig","onScatterToChase","onChaseToScatter","onDead","interpret","makeGhostStateChart","color","colorCode","initialWaitingTimeInBox","onTransition","handleStateTransition","changed","stateChartState","stateChanges","killedGhosts","score","deadWaitingTimeInBoxLeft","GhostDeadSound","event","screenCoordinates","ghostPaused","value","matches","round","timestamp","ghostNumber","energizerTimer","timeLeft","frightenedAboutToEnd","origin","destination","way","workingDirection","some","wayPoint","findWayPoints","canPassThroughBoxDoor","alive","isInsideBoxWalls","isOutsideBoxSpace","resetGhosts","ghosts","setTileCoordinates","resetGhost","Maze","INITIAL_PACMAN_STATE","PacManStateChart","eating","COLLISION_WITH_GHOST","chasing","entry","PacMan","onChasing","makePacManStateChart","nextDirection","handleTransition","diedAtTimestamp","dieSound","resetPacMan","pacMan","Game","store","speed","maze","handleEnergizerTimedOut","makeGhosts","extraLivesLeft","Boolean","localStorage","getItem","DebugState","hitBox","wayPoints","somePlaceholder","Store","debugState","level","readyGameForPlay","setGameLevel","muteGame","StoreContext","createContext","StoreProvider","Provider","useStore","useContext","useGame","collide","rect1","rect2","eatEnergizer","getPillHitBox","pill","PILL_BOX_HIT_BOX_WIDTH","getPacManHitBox","PAC_MAN_HIT_BOX_WIDTH","PAC_MAN_HIT_BOX_HEIGHT","getGhostHitBox","GHOST_HIT_BOX_WIDTH","GHOST_HIT_BOX_HEIGHT","eatPillLayerObject","pills","eatPill","EatPillSound","ghostCollidesWithPacMan","detectCollisions","pillTile","pillHitBox","pacManHitBox","detectPacManEatingPill","ghostHitBox","detectGhostCollisions","TILE_FOR_LEAVING_THE_BOX","TILE_FOR_RETURNING_TO_BOX","SCATTER_TILE_FOR_GHOST_0","chooseInScatterMode","chooseForGhost2InChaseState","from","to","intermediateTile","chooseGhost2IntermediateTile","blinky","vectorToBlinky","rotatedVector","twoTilesAhead","choseInChaseMode","chooseForGhost0InChaseState","fourTilesAhead","chooseForGhost1InChaseState","chooseForGhost3InChaseState","chooseInFrightenedMode","chooseSomeRandomMovement","candidateDirections","filter","length","max","newDirection","random","chooseInDeadMode","updateGhost","updateDeadWaitingTimeInBoxLeft","routeAndMoveGhost","reRouteGhost","moveGhost","chooseNewTargetTile","updateDirection","updateSpeed","getNewDirection","newSpeedFactor","getNewSpeedFactor","speedFactor","getGhostMovementVector","moveGhostBy","TotalPacManDyingAnimationLength","keys","PacManDyingPhaseLength","movePacManBy","updateLivingPacMan","movePacMan","gameSpeed","getPacManSpeed","delta","directionAsVector","updateDeadPacMan","timeSinceDeath","revivePacMan","onAnimationFrame","externalTimeStamp","updateExternalTimestamp","gamePaused","frameCount","updateGameTimestamp","updateEnergizerTimer","updatePacMan","updateGhosts","useGameLoop","animationStep","requestRef","useRef","animate","current","requestAnimationFrame","useEffect","cancelAnimationFrame","useAnimationLoop","RestartView","ButtonStyled","onClick","resetGame","styled","button","Score","observer","className","classNames","PauseView","SIZE_MAPPING","small","medium","large","mappedSize","size","VSpace","div","Board","children","scale","Sprite","spriteName","style","position","left","top","transform","transformOrigin","MazeView","Box","rect","backgroundColor","zIndex","BasicPillView","EnergizerView","PillView","PillsView","memo","map","_","displayName","PacManView","gameViewOptions","pacManAnimationPhase","getPacManAnimationPhase","dyingPhase","PacManDyingPhaseCount","getPacManDyingPhase","PAC_MAN_WIDTH","PAC_MAN_HEIGHT","dyingPacManAnimationPhase","PacManSprite","DyingPacManSprite","PacManHitBox","POINTS","DirectionToAngle","WayPoint","angle","SvgStyled","viewBox","points","fill","stroke","strokeWidth","svg","WayPoints","index","getDirection","indexToUse","fromTile","toTile","Target","version","d","GhostsGameView","ghostViewOptions","GhostsView","DefaultGhostViewOptions","DefaultGameViewOptions","GhostCompositeView","GhostView","animationPhase","frightenedGhostTime","ghostAnimationPhase","GHOST_WIDTH","GHOST_HEIGHT","GhostSprite","phase","DeadGhostSprite","FrightenedGhostSprite","GhostHitBox","Message","text","MessageStyled","span","GameOver","gameOver","ExtraLives","Layout","times","n","useIsomorphicLayoutEffect","window","useLayoutEffect","useEventListener","eventName","handler","element","options","savedHandler","targetElement","addEventListener","listener","removeEventListener","label","LevelView","useState","isOpen","setIsOpen","selectedOption","setSelectedOption","isConnected","isArray","every","r","contains","useOnClickOutside","StyledDropdown","StyledDropdownControl","prevIsOpen","StyledDropdownContent","item","StyledDropdownItem","option","Number","SoundOff","xmlns","SoundOn","SoundView","setIsMuted","StyledButton","muteSounds","setItem","removeItem","GameBoard","contentRef","setScale","handleResize","contentWidth","scrollWidth","contentHeight","scrollHeight","getContentHeight","screenWidth","innerWidth","screenHeight","innerHeight","widthFit","heightFit","newScale","min","useScaleElement","Container","ScoreArea","justify","BoardArea","SettingsArea","StartSound","startSound","useMemo","then","catch","pause","src","muted","GamePage","isStarted","setIsStarted","onKeyDown","useCallback","pressedKey","key","document","useKeyboardActions","data-testid","StartButton","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.4c181729.chunk.js","sourcesContent":["export function assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(`Assertion error ${msg ?? ''}`);\n  }\n}\n","import { assert } from '../util/assert';\n\nexport type PixelsPerFrame = number;\n\nexport type Direction = 'UP' | 'DOWN' | 'RIGHT' | 'LEFT';\n\nexport const Directions: Direction[] = ['UP', 'DOWN', 'LEFT', 'RIGHT'];\n\nexport type MilliSeconds = number;\n\nexport const assertValidDirection = (direction: Direction) => {\n  assert(Directions.includes(direction), `Bad direction ${direction}`);\n};\n","import MapData from '../mapData/pacman6.json';\n\nexport type TileId = number;\n\nexport const EMPTY_TILE_ID: TileId = 0;\nexport const BASIC_PILL_ID: TileId = 3533;\nexport const ENERGIZER_ID: TileId = 3589;\n\nexport const WAY_FREE_ID: TileId = 5240;\nexport const BOX_DOOR_ID: TileId = 5241;\n\nexport type TileMatrix = TileId[][];\n\ninterface Layer {\n  data: number[];\n  width: number;\n  height: number;\n}\n\nconst getLayer = (layerName: string): Layer => {\n  const layer = MapData.layers.find(layer => layer.name === layerName);\n  if (!layer) {\n    throw new Error(`${layerName} layer not found`);\n  }\n  return layer;\n};\n\nconst pillsLayer: Layer = getLayer('Pills');\nconst waysLayer: Layer = getLayer('Ways');\n\nexport const MAZE_WIDTH_IN_TILES = pillsLayer.width;\nexport const MAZE_HEIGHT_IN_TILES = pillsLayer.height;\n\nexport const getTileMatrix = (data: TileId[]): TileMatrix => {\n  const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\n  let dataIndex = 0;\n  for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\n    tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\n    for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\n      const tileId = data[dataIndex];\n      tileMatrix[ty][tx] = tileId;\n      dataIndex++;\n    }\n  }\n  return tileMatrix;\n};\n\nexport const getPillsMatrix = (): TileMatrix => getTileMatrix(pillsLayer.data);\n\nexport const waysMatrix: TileMatrix = getTileMatrix(waysLayer.data);\n","import { MAZE_WIDTH_IN_TILES, MAZE_HEIGHT_IN_TILES } from './MazeData';\nimport { assert } from '../util/assert';\nimport { Vector } from './Vector';\n\nexport type Coordinate = number;\n\nexport type TileCoordinate = Coordinate;\nexport type ScreenCoordinate = Coordinate;\n\nexport interface TileCoordinates {\n  x: TileCoordinate;\n  y: TileCoordinate;\n}\n\nexport interface ScreenCoordinates {\n  x: ScreenCoordinate;\n  y: ScreenCoordinate;\n}\n\nexport type Coordinates = TileCoordinates | ScreenCoordinates;\n\nexport interface TileRectangle {\n  tile1: TileCoordinates;\n  tile2: TileCoordinates;\n}\n\nexport const SCALE_FACTOR = 2.5;\nexport const SPRITE_TILE_SIZE = 8;\nexport const SCREEN_TILE_SIZE = SPRITE_TILE_SIZE * SCALE_FACTOR;\nexport const SCREEN_TILE_CENTER = SCREEN_TILE_SIZE / 2;\n\nexport const SCREEN_TILE_CENTER_VECTOR: Vector = {\n  x: SCREEN_TILE_CENTER,\n  y: SCREEN_TILE_CENTER,\n};\n\nexport const MAZE_WIDTH_IN_SCREEN_COORDINATES =\n  MAZE_WIDTH_IN_TILES * SCREEN_TILE_SIZE;\nexport const MAZE_HEIGHT_IN_SCREEN_COORDINATES =\n  MAZE_HEIGHT_IN_TILES * SCREEN_TILE_SIZE;\n\nexport const MAZE_DIMENSIONS_IN_TILES: TileCoordinates = {\n  x: MAZE_WIDTH_IN_TILES,\n  y: MAZE_HEIGHT_IN_TILES,\n};\n\nexport const isTxValid = (tx: TileCoordinate) =>\n  tx >= 0 && tx < MAZE_WIDTH_IN_TILES;\nexport const isTyValid = (ty: TileCoordinate) =>\n  ty >= 0 && ty < MAZE_HEIGHT_IN_TILES;\nexport const isValidTileCoordinates = (tile: TileCoordinates) =>\n  isTxValid(tile.x) && isTyValid(tile.y);\n\nexport const assertValidTx = (tx: TileCoordinate) => {\n  assert(isTxValid(tx), `Invalid t.x ${tx} width: ${MAZE_WIDTH_IN_TILES}`);\n};\n\nexport const assertValidTy = (ty: TileCoordinate) => {\n  assert(isTyValid(ty), `Invalid t.y ${ty} height: ${MAZE_HEIGHT_IN_TILES}`);\n};\n\nexport const assertValidTileCoordinates = (tile: TileCoordinates) => {\n  assertValidTx(tile.x);\n  assertValidTy(tile.y);\n};\n\nexport const screenFromTileCoordinate = (\n  tileCoordinate: TileCoordinate\n): ScreenCoordinate => tileCoordinate * SCREEN_TILE_SIZE;\n\nexport const tileFromScreenCoordinate = (\n  screenCoordinate: ScreenCoordinate\n): TileCoordinate => Math.floor(screenCoordinate / SCREEN_TILE_SIZE);\n\nexport const screenFromTile = (tile: TileCoordinates): ScreenCoordinates => ({\n  x: screenFromTileCoordinate(tile.x),\n  y: screenFromTileCoordinate(tile.y),\n});\n\nexport const tileFromScreen = (screen: ScreenCoordinates): TileCoordinates => ({\n  x: tileFromScreenCoordinate(screen.x),\n  y: tileFromScreenCoordinate(screen.y),\n});\n\nexport const getPointDifferenceAsVector = (\n  from: Coordinates,\n  to: Coordinates\n): Vector => ({\n  x: to.x - from.x,\n  y: to.y - from.y,\n});\n\nexport const addCoordinatesAndVector = (\n  coordinates: Coordinates,\n  vector: Vector\n): ScreenCoordinates => ({\n  x: coordinates.x + vector.x,\n  y: coordinates.y + vector.y,\n});\n\nexport const rectangleContainsTile = (\n  tileRectangle: TileRectangle,\n  tile: TileCoordinates\n): boolean =>\n  tile.x >= tileRectangle.tile1.x &&\n  tile.x <= tileRectangle.tile2.x &&\n  tile.y >= tileRectangle.tile1.y &&\n  tile.y <= tileRectangle.tile2.y;\n\nexport const wrapTileToBounds = (\n  tile: TileCoordinates,\n  bounds: TileCoordinates\n): TileCoordinates => {\n  const wrappedX = (tile.x + bounds.x) % bounds.x;\n  const wrappedY = (tile.y + bounds.y) % bounds.y;\n  return { x: wrappedX, y: wrappedY };\n};\n","export interface Vector {\n  x: number;\n  y: number;\n}\n\nexport const rotateVectorBy180Degrees = (vector: Vector): Vector =>\n  multiplyVector(-1, vector);\n\nexport const multiplyVector = (factor: number, vector: Vector): Vector => ({\n  x: factor * vector.x,\n  y: factor * vector.y,\n});\n\nexport const divideVector = (vector: Vector, divisor: number): Vector =>\n  multiplyVector(1 / divisor, vector);\n","import { Direction, assertValidDirection } from './Types';\nimport {\n  assertValidTileCoordinates,\n  ScreenCoordinates,\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  rectangleContainsTile,\n  TileRectangle,\n  wrapTileToBounds,\n  MAZE_DIMENSIONS_IN_TILES,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { waysMatrix, WAY_FREE_ID, BOX_DOOR_ID } from './MazeData';\nimport { Vector, multiplyVector } from './Vector';\n\nconst BOX_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 10, y: 12 },\n  tile2: { x: 17, y: 16 },\n};\n\nconst BOX_SPACE_TILE_COORDINATES: TileRectangle = {\n  tile1: { x: 12, y: 14 },\n  tile2: { x: 15, y: 14 },\n};\n\nexport const isWayFreeAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === WAY_FREE_ID;\n};\n\nexport const isBoxDoorAt = (tile: TileCoordinates): boolean => {\n  assertValidTileCoordinates(tile);\n  return waysMatrix[tile.y][tile.x] === BOX_DOOR_ID;\n};\n\nexport const isTileInBox = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_TILE_COORDINATES, tile);\n\nexport const isTileInBoxSpace = (tile: TileCoordinates): boolean =>\n  rectangleContainsTile(BOX_SPACE_TILE_COORDINATES, tile);\n\nexport const isTileCenter = (screen: ScreenCoordinates): boolean => {\n  return screen.x % SCREEN_TILE_SIZE === 0 && screen.y % SCREEN_TILE_SIZE === 0;\n};\n\nexport const DIRECTION_TO_VECTOR: Record<Direction, Vector> = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n\nexport const directionToVector = (direction: Direction, distance = 1): Vector =>\n  multiplyVector(distance, DIRECTION_TO_VECTOR[direction]);\n\nexport const moveFromTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  steps = 1\n) => {\n  const step = DIRECTION_TO_VECTOR[direction];\n  const newTile = { x: tile.x + step.x * steps, y: tile.y + step.y * steps };\n  return newTile;\n};\n\nexport const DIRECTION_TO_OPPOSITE_DIRECTION: Record<Direction, Direction> = {\n  RIGHT: 'LEFT',\n  LEFT: 'RIGHT',\n  UP: 'DOWN',\n  DOWN: 'UP',\n};\n\nexport const isOppositeDirection = (\n  direction1: Direction,\n  direction2: Direction\n) => {\n  return DIRECTION_TO_OPPOSITE_DIRECTION[direction1] === direction2;\n};\n\nexport const isWayFreeInDirection = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): boolean => {\n  const nextTile = getNextTile(tile, direction, stepSize);\n  return isWayFreeAt(nextTile);\n};\n\nexport const getNextTile = (\n  tile: TileCoordinates,\n  direction: Direction,\n  stepSize = 1\n): TileCoordinates => {\n  assertValidDirection(direction);\n  const vector: Vector = DIRECTION_TO_TILE_VECTOR[direction];\n  const scaledVector = multiplyVector(stepSize, vector);\n  const movedTile = addCoordinatesAndVector(tile, scaledVector);\n  const nextTile = wrapTileToBounds(movedTile, MAZE_DIMENSIONS_IN_TILES);\n  return nextTile;\n};\n\nconst DIRECTION_TO_TILE_VECTOR = {\n  RIGHT: { x: 1, y: 0 },\n  LEFT: { x: -1, y: 0 },\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n};\n","import { Ghost } from './Ghost';\nimport { DIRECTION_TO_OPPOSITE_DIRECTION } from './Ways';\n\nexport const changeDirectionToOpposite = (ghost: Ghost) => {\n  ghost.direction = DIRECTION_TO_OPPOSITE_DIRECTION[ghost.direction];\n};\n","import { TileCoordinates } from './Coordinates';\n\nexport const getTileDistance = (\n  neighbourTile: TileCoordinates,\n  targetTile: TileCoordinates\n) => {\n  const dx = Math.abs(neighbourTile.x - targetTile.x);\n  const dy = Math.abs(neighbourTile.y - targetTile.y);\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n","import { minBy } from 'lodash';\nimport { isValidTileCoordinates, TileCoordinates } from './Coordinates';\nimport { Direction, Directions } from './Types';\nimport {\n  getNextTile,\n  isOppositeDirection,\n  isWayFreeAt,\n  isBoxDoorAt,\n} from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { toJS } from 'mobx';\nimport { assert } from '../util/assert';\n\ninterface CandidateTile {\n  tile: TileCoordinates;\n  distanceToTarget: number;\n}\n\nexport const chooseNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates => {\n  assert(isValidTileCoordinates(currentTile), `${toJS(currentTile)}`);\n  const bestNextTile = chooseBestNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  if (bestNextTile) {\n    assert(isValidTileCoordinates(bestNextTile));\n    return bestNextTile;\n  }\n\n  const anyNextTile = chooseAnyNextTile({\n    currentTile,\n    currentDirection,\n    boxDoorIsOpen,\n  });\n  if (anyNextTile) {\n    assert(isValidTileCoordinates(anyNextTile));\n    return anyNextTile;\n  }\n\n  console.error('currentTile', currentTile);\n  console.error('currentDirection', currentDirection);\n  console.error('boxDoorIsOpen', boxDoorIsOpen);\n  console.error('targetTile', toJS(targetTile));\n\n  throw new Error(`Found no candidate at ${JSON.stringify(currentTile)}`);\n};\n\nconst chooseBestNextTile = ({\n  currentTile,\n  currentDirection,\n  targetTile,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  targetTile: TileCoordinates;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  const candidates = [] as CandidateTile[];\n  for (const direction of Directions) {\n    // Prevent the ghost from going backwards\n    if (isOppositeDirection(direction, currentDirection)) {\n      continue;\n    }\n    const neighbourTile = getNextTile(currentTile, direction);\n\n    if (!possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      continue;\n    }\n\n    const distanceToTarget = getTileDistance(neighbourTile, targetTile);\n    candidates.push({ tile: neighbourTile, distanceToTarget });\n  }\n\n  const bestCandidate = minBy(candidates, 'distanceToTarget');\n  if (bestCandidate) {\n    return bestCandidate.tile;\n  } else {\n    return null;\n  }\n};\n\nconst chooseAnyNextTile = ({\n  currentTile,\n  currentDirection,\n  boxDoorIsOpen,\n}: {\n  currentTile: TileCoordinates;\n  currentDirection: Direction;\n  boxDoorIsOpen: boolean;\n}): TileCoordinates | null => {\n  // Prioritize the current direction\n  const neighbourTileInCurrentDirection = getNextTile(\n    currentTile,\n    currentDirection\n  );\n\n  if (possibleNextTile(neighbourTileInCurrentDirection, boxDoorIsOpen)) {\n    return neighbourTileInCurrentDirection;\n  }\n\n  // Choose any possible next tile\n  for (const direction of Directions) {\n    const neighbourTile = getNextTile(currentTile, direction);\n    if (possibleNextTile(neighbourTile, boxDoorIsOpen)) {\n      return neighbourTile;\n    }\n  }\n\n  return null;\n};\n\nconst possibleNextTile = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean => {\n  return (\n    isValidTileCoordinates(tileCoordinates) &&\n    isWayFreeForGhostAt(tileCoordinates, boxDoorIsOpen)\n  );\n};\n\nconst isWayFreeForGhostAt = (\n  tileCoordinates: TileCoordinates,\n  boxDoorIsOpen: boolean\n): boolean =>\n  isWayFreeAt(tileCoordinates) ||\n  (boxDoorIsOpen && isBoxDoorAt(tileCoordinates));\n","import { TileCoordinates, TileCoordinate } from './Coordinates';\nimport { isEqual } from 'lodash';\nimport { assert } from '../util/assert';\nimport { Direction } from './Types';\nimport { MAZE_WIDTH_IN_TILES } from './MazeData';\n\nconst TUNNEL_X_LEFT: TileCoordinate = 0;\nconst TUNNEL_X_RIGHT: TileCoordinate = MAZE_WIDTH_IN_TILES - 1;\n\nexport const getDirectionFromTileToTile = (\n  tileFrom: TileCoordinates,\n  tileTo: TileCoordinates\n): Direction => {\n  assert(tileFrom, 'tileFrom');\n  assert(tileTo, 'tileTo');\n\n  if (isEqual(tileFrom, tileTo)) {\n    throw new Error('Same tile');\n  }\n\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_RIGHT && tileTo.x === TUNNEL_X_LEFT) {\n    return 'RIGHT';\n  }\n  // Go through the tunnel?\n  if (tileFrom.x === TUNNEL_X_LEFT && tileTo.x === TUNNEL_X_RIGHT) {\n    return 'LEFT';\n  }\n  if (tileFrom.x < tileTo.x) {\n    return 'RIGHT';\n  }\n  if (tileFrom.x > tileTo.x) {\n    return 'LEFT';\n  }\n  if (tileFrom.y < tileTo.y) {\n    return 'DOWN';\n  }\n  if (tileFrom.y > tileTo.y) {\n    return 'UP';\n  }\n  throw new Error('Same tiles');\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_GHOST_STATE = 'scatter';\n\ninterface GhostEventHandler {\n  onScatterToChase(): void;\n  onChaseToScatter(): void;\n  onDead(): void;\n}\n\ntype GhostContext = {};\n\ninterface GhostStateSchema {\n  states: {\n    chase: {};\n    scatter: {};\n    frightened: {};\n    dead: {};\n  };\n}\n\nexport type GhostEventType =\n  | 'RESET'\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'PHASE_END'\n  | 'COLLISION_WITH_PAC_MAN'\n  | 'REVIVED';\n\ntype GhostEvent = { type: GhostEventType };\n\nexport type GhostState = State<GhostContext, GhostEvent, GhostStateSchema, any>;\n\nconst GhostStateChart = Machine<GhostContext, GhostStateSchema, GhostEvent>({\n  id: 'ghost',\n  initial: INITIAL_GHOST_STATE,\n  on: {\n    RESET: INITIAL_GHOST_STATE,\n  },\n  states: {\n    chase: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'scatter',\n          actions: 'onChaseToScatter',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    scatter: {\n      on: {\n        ENERGIZER_EATEN: 'frightened',\n        PHASE_END: {\n          target: 'chase',\n          actions: 'onScatterToChase',\n        },\n        COLLISION_WITH_PAC_MAN: {\n          target: 'scatter',\n        },\n      },\n    },\n    frightened: {\n      on: {\n        ENERGIZER_TIMED_OUT: 'chase',\n        COLLISION_WITH_PAC_MAN: {\n          target: 'dead',\n          actions: 'onDead',\n        },\n      },\n    },\n    dead: {\n      on: {\n        REVIVED: 'scatter',\n        ENERGIZER_TIMED_OUT: 'scatter',\n      },\n    },\n  },\n});\n\nexport const makeGhostStateChart = (eventHandler: GhostEventHandler) => {\n  const extended = GhostStateChart.withConfig({\n    actions: {\n      onScatterToChase: eventHandler.onScatterToChase,\n      onChaseToScatter: eventHandler.onChaseToScatter,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","import { MilliSeconds } from './Types';\nimport { observable, computed, action } from 'mobx';\n\nexport type TimerCallback = () => void;\n\nexport class TimeoutTimer {\n  duration: MilliSeconds;\n  readonly onTimedOut: TimerCallback | null;\n\n  @observable\n  running: boolean;\n\n  @observable\n  timeSpent: MilliSeconds;\n\n  constructor(duration: MilliSeconds, onTimedOut: TimerCallback | null = null) {\n    this.duration = duration;\n    this.onTimedOut = onTimedOut;\n    this.running = false;\n    this.timeSpent = 0;\n  }\n\n  @action\n  setDuration(duration: MilliSeconds) {\n    this.duration = duration;\n  }\n\n  @action.bound\n  start() {\n    this.running = true;\n    this.timeSpent = 0;\n  }\n\n  @action\n  advance(timePassed: MilliSeconds) {\n    if (!this.running) {\n      return;\n    }\n    this.timeSpent += timePassed;\n    if (this.isTimedOut) {\n      this.onTimedOut?.();\n      this.stop();\n    }\n  }\n\n  @action\n  stop() {\n    this.running = false;\n  }\n\n  restart() {\n    this.stop();\n    this.start();\n  }\n\n  @computed\n  get timeLeft() {\n    return this.duration - this.timeSpent;\n  }\n\n  @computed\n  get isTimedOut() {\n    return this.timeSpent >= this.duration;\n  }\n}\n","import { action } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { MilliSeconds } from './Types';\nimport { StateValue } from 'xstate';\n\nexport const CHASE_PHASE_LENGTH = 20 * 1000;\nexport const SCATTER_PHASE_LENGTH = 7 * 1000;\n\nexport const updateGhostStatePhaseTime = action(\n  'updateGhostStatePhaseTime',\n  (ghost: Ghost) => {\n    ghost.statePhaseTimer.advance(ghost.game.lastFrameLength);\n  }\n);\n\nexport const updateGhostStatePhase = action(\n  'updateGhostStatePhase',\n  (ghost: Ghost) => {\n    if (!ghost.atTileCenter) {\n      return;\n    }\n\n    if (ghost.statePhaseTimer.isTimedOut) {\n      ghost.send('PHASE_END');\n      ghost.statePhaseTimer.setDuration(getStatePhaseLength(ghost.state));\n      ghost.statePhaseTimer.restart();\n    }\n  }\n);\n\nexport const getStatePhaseLength = (state: StateValue): MilliSeconds => {\n  switch (state) {\n    case 'chase':\n      return CHASE_PHASE_LENGTH;\n    case 'scatter':\n      return SCATTER_PHASE_LENGTH;\n    default:\n      // Never ends\n      return 9999999999;\n  }\n};\n","export default __webpack_public_path__ + \"static/media/ghost_dead.a3650929.mp3\";","import { Game } from './Game';\n\nexport const getSoundPlay = (url: string, game: Game, volume = 0.5) => {\n  if (game.gameStarted && !game.isMuted) {\n    const sound = new Audio(url);\n    sound.play();\n    sound.volume = volume;\n  }\n};\n","import { action, computed, observable } from 'mobx';\nimport { changeDirectionToOpposite } from './changeDirectionToOpposite';\nimport {\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n  tileFromScreen,\n} from './Coordinates';\nimport { findWayPoints } from './findWayPoints';\nimport { Game } from './Game';\nimport {\n  GhostEventType,\n  makeGhostStateChart,\n  GhostState,\n} from './GhostStateChart';\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  isTileInBox as isTileInBoxWalls,\n  isTileCenter,\n  isTileInBoxSpace,\n} from './Ways';\nimport { StateValue } from 'xstate';\nimport { TimeoutTimer } from './TimeoutTimer';\nimport { getStatePhaseLength } from './updateGhostStatePhase';\nimport GhostDeadSound from '../resources/sfx/ghost_dead.mp3';\nimport { getSoundPlay } from './getSoundPlay';\n\nexport type GhostNumber = 0 | 1 | 2 | 3;\nexport const GhostNumbers: GhostNumber[] = [0, 1, 2, 3];\nexport type GhostAnimationPhase = 0 | 1;\nexport const GhostAnimationPhases: GhostAnimationPhase[] = [0, 1];\nexport type FrightenedGhostTime = 0 | 1;\nexport const FrightenedGhostTimes: FrightenedGhostTime[] = [0, 1];\n\nconst FRIGHTENED_ABOUT_TO_END_DURATION: MilliSeconds = 3000;\nconst DEAD_WAITING_IN_BOX_DURATION: MilliSeconds = 7000;\n\nexport const KILL_GHOST_SCORE = [0, 100, 200, 400, 800, 1600, 3200];\n\nexport class Ghost {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleStateTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleStateTransition(state: GhostState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n    this.stateChanges++;\n  }\n\n  stateChart = makeGhostStateChart({\n    onScatterToChase: this.onScatterToChase,\n    onChaseToScatter: this.onChaseToScatter,\n    onDead: this.onDead,\n  });\n\n  @action.bound\n  onDead() {\n    this.game.killedGhosts++;\n    this.game.score += KILL_GHOST_SCORE[this.game.killedGhosts];\n    this.deadWaitingTimeInBoxLeft = DEAD_WAITING_IN_BOX_DURATION;\n    getSoundPlay(GhostDeadSound, this.game);\n  }\n\n  @action.bound\n  onScatterToChase() {\n    changeDirectionToOpposite(this);\n  }\n\n  @action.bound\n  onChaseToScatter() {\n    changeDirectionToOpposite(this);\n  }\n\n  @observable.ref\n  stateChartState: GhostState = this.stateChart.state;\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  @observable\n  stateChanges = 0;\n\n  @computed\n  get dead() {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @computed get frightened(): boolean {\n    return this.stateChartState.matches('frightened');\n  }\n\n  name = 'ghost name';\n\n  send(event: GhostEventType) {\n    this.stateChart.send(event);\n  }\n\n  @observable\n  ghostPaused = true;\n\n  game: Game;\n\n  @observable\n  ghostNumber: GhostNumber = 0;\n\n  color = 'ghost color';\n  colorCode = '#00ffff';\n\n  @observable\n  screenCoordinates: ScreenCoordinates = {\n    x: 16,\n    y: 16,\n  };\n\n  @computed\n  get atTileCenter(): boolean {\n    return isTileCenter(this.screenCoordinates);\n  }\n\n  @observable\n  speedFactor = 1;\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @computed\n  get animationPhase(): GhostAnimationPhase {\n    return Math.round((this.game.timestamp + this.ghostNumber * 100) / 300) %\n      2 ===\n      0\n      ? 0\n      : 1;\n  }\n\n  @computed\n  get frightenedAboutToEnd(): boolean {\n    return this.game.energizerTimer.timeLeft < FRIGHTENED_ABOUT_TO_END_DURATION;\n  }\n\n  @observable\n  deadWaitingTimeInBoxLeft: MilliSeconds = 0;\n\n  @computed\n  get frightenedGhostTime(): FrightenedGhostTime {\n    if (!this.frightenedAboutToEnd) {\n      return 0;\n    }\n    // Blink every 0.5 seconds\n    return this.game.timestamp % 1000 < 500 ? 0 : 1;\n  }\n\n  @observable\n  direction: Direction = 'LEFT';\n\n  @observable\n  targetTile: TileCoordinates = { x: 1, y: 1 };\n\n  @computed\n  get wayPoints(): TileCoordinates[] | null {\n    return findWayPoints(\n      this.tileCoordinates,\n      this.targetTile,\n      this.direction,\n      this.canPassThroughBoxDoor\n    );\n  }\n\n  statePhaseTimer = new TimeoutTimer(3000);\n\n  @computed\n  get isInsideBoxWalls(): boolean {\n    return isTileInBoxWalls(this.tileCoordinates);\n  }\n\n  @computed\n  get isOutsideBoxSpace() {\n    return !isTileInBoxSpace(this.tileCoordinates);\n  }\n\n  @computed\n  get canPassThroughBoxDoor(): boolean {\n    if (this.alive) {\n      if (this.isInsideBoxWalls) {\n        if (this.game.timestamp > this.initialWaitingTimeInBox) {\n          return true;\n        }\n      }\n    }\n\n    if (this.dead) {\n      if (this.isOutsideBoxSpace) {\n        return true;\n      }\n\n      // Dead && Inside box\n      if (this.deadWaitingTimeInBoxLeft <= 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  @action\n  resetGhost() {\n    this.ghostPaused = false;\n    this.send('RESET');\n    this.statePhaseTimer.setDuration(getStatePhaseLength(this.state));\n    this.statePhaseTimer.restart();\n  }\n\n  initialWaitingTimeInBox = 0;\n}\n","import { TileCoordinates } from './Coordinates';\nimport { Direction } from './Types';\nimport { isEqual } from 'lodash';\nimport { chooseNextTile } from './chooseNextTile';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\n\nexport const findWayPoints = (\n  origin: TileCoordinates,\n  destination: TileCoordinates,\n  currentDirection: Direction,\n  boxDoorIsOpen: boolean\n): TileCoordinates[] | null => {\n  const way: TileCoordinates[] = [origin];\n  let currentTile = origin;\n  let workingDirection = currentDirection;\n  while (!isEqual(currentTile, destination)) {\n    const nextTile = chooseNextTile({\n      currentTile,\n      currentDirection: workingDirection,\n      targetTile: destination,\n      boxDoorIsOpen,\n    });\n    // Prevent endless iteration\n    if (way.some(wayPoint => isEqual(wayPoint, nextTile))) {\n      return way;\n    }\n    way.push(nextTile);\n    workingDirection = getDirectionFromTileToTile(\n      currentTile,\n      nextTile\n    ) as Direction;\n    currentTile = nextTile;\n  }\n  return way;\n};\n","import { Game } from './Game';\nimport { Ghost } from './Ghost';\n\nexport const resetGhosts = (ghosts: Ghost[]) => {\n  ghosts[0].setTileCoordinates({ x: 12, y: 14 });\n  ghosts[0].direction = 'LEFT';\n  ghosts[1].setTileCoordinates({ x: 13, y: 14 });\n  ghosts[1].direction = 'RIGHT';\n  ghosts[2].setTileCoordinates({ x: 14, y: 14 });\n  ghosts[3].direction = 'LEFT';\n  ghosts[3].setTileCoordinates({ x: 15, y: 14 });\n  ghosts[3].direction = 'RIGHT';\n\n  for (const ghost of ghosts) {\n    ghost.resetGhost();\n  }\n};\n\nexport const makeGhosts = (game: Game): Ghost[] => {\n  const ghosts: Ghost[] = [\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n    new Ghost(game),\n  ];\n\n  ghosts[0].ghostNumber = 0;\n  ghosts[0].name = 'Blinky';\n  ghosts[0].color = 'red';\n  ghosts[0].colorCode = '#ff0000';\n  ghosts[0].initialWaitingTimeInBox = 1000;\n\n  ghosts[1].ghostNumber = 1;\n  ghosts[1].name = 'Pinky';\n  ghosts[1].color = 'pink';\n  ghosts[1].colorCode = '#fcb5ff';\n  ghosts[1].initialWaitingTimeInBox = 1300;\n\n  ghosts[2].ghostNumber = 2;\n  ghosts[2].name = 'Inky';\n  ghosts[2].color = 'blue';\n  ghosts[2].colorCode = '#00ffff';\n  ghosts[2].initialWaitingTimeInBox = 1600;\n\n  ghosts[3].ghostNumber = 3;\n  ghosts[3].name = 'Clyde';\n  ghosts[3].color = 'orange';\n  ghosts[3].colorCode = '#f9ba55';\n  ghosts[3].initialWaitingTimeInBox = 1900;\n\n  resetGhosts(ghosts);\n\n  return ghosts;\n};\n","import { observable } from 'mobx';\nimport { getPillsMatrix, TileId } from './MazeData';\n\nexport class Maze {\n  @observable\n  pills: TileId[][] = getPillsMatrix();\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport { Machine, interpret, State } from 'xstate';\n\nexport const INITIAL_PACMAN_STATE = 'eating';\n\ninterface EventHandler {\n  onChasing(): void;\n  onDead(): void;\n}\n\ntype PacManContext = {};\n\ninterface PacManStateSchema {\n  states: {\n    eating: {};\n    chasing: {};\n    dead: {};\n  };\n}\n\nexport type PacManEventType =\n  | 'ENERGIZER_EATEN'\n  | 'ENERGIZER_TIMED_OUT'\n  | 'COLLISION_WITH_GHOST'\n  | 'REVIVED';\n\ntype PacManEvent = { type: PacManEventType };\n\nexport type PacManState = State<\n  PacManContext,\n  PacManEvent,\n  PacManStateSchema,\n  any\n>;\n\nconst PacManStateChart = Machine<PacManContext, PacManStateSchema, PacManEvent>(\n  {\n    id: 'pac-man',\n    initial: INITIAL_PACMAN_STATE,\n    states: {\n      eating: {\n        on: {\n          ENERGIZER_EATEN: 'chasing',\n          COLLISION_WITH_GHOST: 'dead',\n        },\n      },\n      chasing: {\n        entry: 'onChasing',\n        on: {\n          ENERGIZER_TIMED_OUT: 'eating',\n        },\n      },\n      dead: {\n        entry: 'onDead',\n        on: {\n          REVIVED: 'eating',\n        },\n      },\n    },\n  }\n);\n\nexport const makePacManStateChart = (eventHandler: EventHandler) => {\n  const extended = PacManStateChart.withConfig({\n    actions: {\n      onChasing: eventHandler.onChasing,\n      onDead: eventHandler.onDead,\n    },\n  });\n  const stateChart = interpret(extended);\n  return stateChart;\n};\n","export default __webpack_public_path__ + \"static/media/die.603710c3.mp3\";","import { observable, action, computed } from 'mobx';\n\nimport { Direction, MilliSeconds } from './Types';\nimport {\n  tileFromScreen,\n  screenFromTile,\n  TileCoordinates,\n  ScreenCoordinates,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport {\n  makePacManStateChart,\n  PacManEventType,\n  INITIAL_PACMAN_STATE,\n  PacManState,\n} from './PacManStateChart';\nimport { Game } from './Game';\nimport { StateValue } from 'xstate';\nimport dieSound from '../resources/sfx/die.mp3';\nimport { getSoundPlay } from './getSoundPlay';\nexport class PacMan {\n  constructor(game: Game) {\n    this.game = game;\n\n    this.stateChart.onTransition(this.handleTransition);\n    this.stateChart.start();\n  }\n\n  @action.bound\n  handleTransition(state: PacManState) {\n    if (!state.changed) {\n      return;\n    }\n    this.stateChartState = state;\n  }\n\n  game: Game;\n\n  stateChart = makePacManStateChart({\n    onChasing: this.onChasing,\n    onDead: this.onDead,\n  });\n\n  @observable.ref\n  stateChartState: PacManState = this.stateChart.state;\n\n  @action.bound\n  onChasing() {\n    this.game.energizerTimer.start();\n  }\n\n  @action.bound\n  onDead() {\n    this.diedAtTimestamp = this.game.timestamp;\n    getSoundPlay(dieSound, this.game);\n  }\n\n  @computed\n  get dead(): boolean {\n    return this.stateChartState.matches('dead');\n  }\n\n  @computed\n  get state(): StateValue {\n    return this.stateChartState.value;\n  }\n\n  send(event: PacManEventType) {\n    this.stateChart.send(event);\n  }\n\n  @computed\n  get alive() {\n    return !this.dead;\n  }\n\n  @observable\n  screenCoordinates: ScreenCoordinates = screenFromTile({ x: 1, y: 1 });\n\n  @action\n  setTileCoordinates(tile: TileCoordinates) {\n    assertValidTileCoordinates(tile);\n    this.screenCoordinates = screenFromTile(tile);\n  }\n\n  @computed\n  get tileCoordinates(): TileCoordinates {\n    return tileFromScreen(this.screenCoordinates);\n  }\n\n  @observable\n  diedAtTimestamp: MilliSeconds = -1;\n\n  @computed\n  get timeSinceDeath(): MilliSeconds {\n    if (this.alive) {\n      return 0;\n    }\n    return this.game.timestamp - this.diedAtTimestamp;\n  }\n\n  @observable\n  extraLivesLeft = 2;\n\n  @observable\n  direction: Direction = 'RIGHT';\n  nextDirection: Direction = 'RIGHT';\n}\n\nexport const resetPacMan = (pacMan: PacMan) => {\n  pacMan.diedAtTimestamp = -1;\n  pacMan.stateChart.state.value = INITIAL_PACMAN_STATE;\n  pacMan.setTileCoordinates({ x: 14, y: 23 });\n  pacMan.nextDirection = 'LEFT';\n  pacMan.direction = 'LEFT';\n};\n","import { action, computed, observable } from 'mobx';\nimport { Ghost } from './Ghost';\nimport { makeGhosts, resetGhosts } from './makeGhosts';\nimport { Maze } from './Maze';\nimport { PacMan, resetPacMan } from './PacMan';\nimport { MilliSeconds, PixelsPerFrame } from './Types';\nimport { Store } from './Store';\nimport { TimeoutTimer } from './TimeoutTimer';\n\nexport const DEFAULT_SPEED = 1;\n\nconst ENERGIZER_DURATION: MilliSeconds = 5000;\n\nexport class Game {\n  constructor(store: Store) {\n    this.store = store;\n    this.pacMan = new PacMan(this);\n    this.ghosts = makeGhosts(this);\n  }\n\n  store: Store;\n\n  //** The timestamp we got from requestAnimationFrame().\n  @observable\n  externalTimeStamp: MilliSeconds | null = null;\n\n  @observable\n  timestamp: MilliSeconds = 0;\n\n  @observable\n  lastFrameLength: MilliSeconds = 17;\n\n  @observable\n  frameCount = 0;\n\n  @observable\n  gamePaused = false;\n\n  speed: PixelsPerFrame = DEFAULT_SPEED;\n\n  ghosts: Ghost[];\n\n  pacMan: PacMan;\n\n  gameStarted = false;\n\n  @observable\n  isMuted = Boolean(localStorage.getItem('pacman-muted'));\n\n  @observable\n  score = 0;\n\n  @observable\n  killedGhosts = 0;\n\n  maze = new Maze();\n\n  @action.bound\n  revivePacMan() {\n    this.pacMan.send('REVIVED');\n    this.timestamp = 0;\n    resetPacMan(this.pacMan);\n    resetGhosts(this.ghosts);\n  }\n\n  @computed\n  get gameOver(): boolean {\n    const pacMan = this.pacMan;\n    return pacMan.dead && pacMan.extraLivesLeft === 0;\n  }\n\n  energizerTimer = new TimeoutTimer(ENERGIZER_DURATION, () => {\n    this.handleEnergizerTimedOut();\n  });\n\n  @action\n  handleEnergizerTimedOut() {\n    this.pacMan.send('ENERGIZER_TIMED_OUT');\n    for (const ghost of this.ghosts) {\n      ghost.send('ENERGIZER_TIMED_OUT');\n    }\n  }\n\n  readyGameForPlay() {\n    resetPacMan(this.pacMan);\n  }\n\n  muteGame() {\n    this.isMuted = !this.isMuted;\n  }\n}\n","import { observable } from 'mobx';\nimport { Store } from './Store';\nimport { GhostViewOptions } from './GhostViewOptions';\nimport { PacManViewOptions } from '../pages/GamePage/components/PacManViewOptions';\nimport { GameViewOptions } from './GameViewOptions';\n\nexport class DebugState {\n  constructor(store: Store) {\n    this.store = store;\n  }\n\n  store: Store;\n\n  @observable\n  gameViewOptions: GameViewOptions = {\n    hitBox: false,\n  };\n\n  @observable\n  ghostViewOptions: GhostViewOptions = {\n    target: false,\n    wayPoints: false,\n  };\n\n  @observable\n  pacManViewOptions: PacManViewOptions = {\n    somePlaceholder: false,\n  };\n}\n","import { observable, action } from 'mobx';\nimport { Game } from './Game';\nimport { DebugState } from './DebugState';\n\nexport class Store {\n  @observable\n  game: Game = new Game(this);\n\n  debugState = new DebugState(this);\n\n  level = 1;\n\n  @action.bound\n  resetGame() {\n    this.game = new Game(this);\n    this.game.readyGameForPlay();\n    this.game.gameStarted = true;\n    this.setGameLevel();\n  }\n  @action.bound\n  muteSounds() {\n    this.game.muteGame();\n  }\n  @action.bound\n  setGameLevel() {\n    this.game.speed = this.level;\n  }\n}\n","import { createContext, useContext } from 'react';\nimport { Game } from '../model/Game';\nimport { assert } from '../util/assert';\nimport { Store } from '../model/Store';\n\nexport const StoreContext = createContext<Store | null>(null);\n\nexport const StoreProvider = StoreContext.Provider;\n\nexport const useStore = (): Store => {\n  const store = useContext(StoreContext);\n  assert(store, 'Store not provided - use <StoreProvider>');\n  return store;\n};\n\nexport const useGame = (): Game => {\n  const store = useStore();\n  return store.game;\n};\n","import { Rectangle } from './Rectangle';\n\nexport const collide = (rect1: Rectangle, rect2: Rectangle): boolean => {\n  return (\n    rect1.x < rect2.x + rect2.width &&\n    rect1.x + rect1.width > rect2.x &&\n    rect1.y < rect2.y + rect2.height &&\n    rect1.y + rect1.height > rect2.y\n  );\n};\n","export default __webpack_public_path__ + \"static/media/eat-fruit.83feae2d.mp3\";","import { Game } from './Game';\nimport { action } from 'mobx';\nimport sound from '../resources/sfx/eat-fruit.mp3';\nimport { getSoundPlay } from './getSoundPlay';\n\nexport const ENERGIZER_POINTS = 30;\n\nexport const eatEnergizer = action((game: Game) => {\n  game.score += ENERGIZER_POINTS;\n  game.killedGhosts = 0;\n  game.pacMan.send('ENERGIZER_EATEN');\n  getSoundPlay(sound, game);\n  for (const ghost of game.ghosts) {\n    ghost.send('ENERGIZER_EATEN');\n  }\n});\n","export default __webpack_public_path__ + \"static/media/pacman_eat.dfc13d55.wav\";","import { collide } from './collisionDetection';\nimport {\n  SCALE_FACTOR,\n  ScreenCoordinates,\n  screenFromTile,\n  TileCoordinates,\n} from './Coordinates';\nimport { eatEnergizer } from './eatEnergizer';\nimport { Game } from './Game';\nimport { Ghost } from './Ghost';\nimport { BASIC_PILL_ID, EMPTY_TILE_ID, ENERGIZER_ID, TileId } from './MazeData';\nimport { Rectangle } from './Rectangle';\nimport EatPillSound from '../resources/sfx/pacman_eat.wav';\nimport { getSoundPlay } from './getSoundPlay';\n\nconst PILL_BOX_HIT_BOX_WIDTH = 2;\nconst PILL_BOX_HIT_BOX_HEIGHT = 2;\n\nexport const getPillHitBox = (\n  tile: TileCoordinates,\n  pill: TileId\n): Rectangle => {\n  const screen = screenFromTile(tile);\n  return {\n    x: screen.x - PILL_BOX_HIT_BOX_WIDTH / 2,\n    y: screen.y - PILL_BOX_HIT_BOX_WIDTH / 2,\n    width: PILL_BOX_HIT_BOX_WIDTH,\n    height: PILL_BOX_HIT_BOX_HEIGHT,\n  };\n};\n\nconst PAC_MAN_HIT_BOX_WIDTH = 15;\nconst PAC_MAN_HIT_BOX_HEIGHT = 15;\n\nexport const getPacManHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - PAC_MAN_HIT_BOX_WIDTH / 2 + 1,\n    y: screen.y - PAC_MAN_HIT_BOX_HEIGHT / 2 + 2,\n    width: PAC_MAN_HIT_BOX_WIDTH,\n    height: PAC_MAN_HIT_BOX_HEIGHT,\n  };\n};\n\nconst GHOST_HIT_BOX_WIDTH = 10;\nconst GHOST_HIT_BOX_HEIGHT = 10;\n\nexport const getGhostHitBox = (screen: ScreenCoordinates): Rectangle => {\n  return {\n    x: screen.x - (GHOST_HIT_BOX_WIDTH * SCALE_FACTOR) / 2,\n    y: screen.y - (GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR) / 2,\n    width: GHOST_HIT_BOX_WIDTH * SCALE_FACTOR,\n    height: GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR,\n  };\n};\n\nconst detectPacManEatingPill = (game: Game) => {\n  const pillTile = game.pacMan.tileCoordinates;\n  const pill: TileId = game.maze.pills[pillTile.y][pillTile.x];\n  if (pill === EMPTY_TILE_ID) {\n    return;\n  }\n\n  const pillHitBox: Rectangle = getPillHitBox(pillTile, pill);\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n  if (collide(pacManHitBox, pillHitBox)) {\n    eatPillLayerObject(pillTile, game);\n  }\n};\n\nexport const BASIC_PILL_POINTS = 10;\n\nconst eatPillLayerObject = (tile: TileCoordinates, game: Game) => {\n  const tileId = game.maze.pills[tile.y][tile.x];\n  switch (tileId) {\n    case BASIC_PILL_ID:\n      eatPill(tile, game);\n      break;\n    case ENERGIZER_ID:\n      eatEnergizer(game);\n      break;\n    default:\n      console.error('Unknown pill layer tile id', tileId);\n      break;\n  }\n\n  game.maze.pills[tile.y][tile.x] = EMPTY_TILE_ID;\n};\n\nconst eatPill = (tile: TileCoordinates, game: Game) => {\n  game.score += BASIC_PILL_POINTS;\n  getSoundPlay(EatPillSound, game, 0.3);\n};\n\nconst detectGhostCollisions = (game: Game) => {\n  const pacManHitBox: Rectangle = getPacManHitBox(\n    game.pacMan.screenCoordinates\n  );\n\n  for (const ghost of game.ghosts) {\n    if (ghost.dead) {\n      continue;\n    }\n\n    const ghostHitBox: Rectangle = getGhostHitBox(ghost.screenCoordinates);\n    if (collide(pacManHitBox, ghostHitBox)) {\n      ghostCollidesWithPacMan(ghost);\n    }\n  }\n};\n\nexport const ghostCollidesWithPacMan = (ghost: Ghost) => {\n  const game = ghost.game;\n  game.pacMan.send('COLLISION_WITH_GHOST');\n  ghost.send('COLLISION_WITH_PAC_MAN');\n};\n\nexport const detectCollisions = (game: Game) => {\n  if (game.pacMan.dead) {\n    return;\n  }\n\n  detectPacManEatingPill(game);\n  detectGhostCollisions(game);\n};\n","import {\n  TileCoordinates,\n  getPointDifferenceAsVector,\n  addCoordinatesAndVector,\n} from './Coordinates';\nimport { Ghost } from './Ghost';\nimport { moveFromTile, isWayFreeInDirection, getNextTile } from './Ways';\nimport { getTileDistance } from './getTileDistance';\nimport { Directions, Direction } from './Types';\nimport { rotateVectorBy180Degrees } from './Vector';\nimport { assert } from '../util/assert';\n\nexport const TILE_FOR_LEAVING_THE_BOX: TileCoordinates = {\n  x: 13,\n  y: 11,\n};\n\nexport const TILE_FOR_RETURNING_TO_BOX: TileCoordinates = {\n  x: 14,\n  y: 14,\n};\n\nexport const SCATTER_TILE_FOR_GHOST_0: TileCoordinates = { x: 26, y: 1 };\n\nexport const chooseNewTargetTile = (ghost: Ghost): TileCoordinates => {\n  switch (ghost.state) {\n    case 'scatter':\n      return chooseInScatterMode(ghost);\n    case 'chase':\n      return choseInChaseMode(ghost);\n    case 'frightened':\n      return chooseInFrightenedMode(ghost);\n    case 'dead':\n      return chooseInDeadMode(ghost);\n    default:\n      throw new Error(`Bad state ${ghost.state}`);\n  }\n};\n\nconst chooseInScatterMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return SCATTER_TILE_FOR_GHOST_0;\n    case 1:\n      return { x: 1, y: 1 };\n    case 2:\n      return { x: 26, y: 29 };\n    case 3:\n      return { x: 1, y: 29 };\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst chooseForGhost0InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  return pacMan.tileCoordinates;\n};\n\nconst chooseForGhost1InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const fourTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    4\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(fourTilesAhead, 'LEFT', 4)\n    : fourTilesAhead;\n};\n\nconst chooseForGhost2InChaseState = (ghost: Ghost): TileCoordinates => {\n  const intermediateTile = chooseGhost2IntermediateTile(ghost);\n  const blinky = ghost.game.ghosts[0];\n  const vectorToBlinky = getPointDifferenceAsVector(\n    intermediateTile,\n    blinky.tileCoordinates\n  );\n  const rotatedVector = rotateVectorBy180Degrees(vectorToBlinky);\n  const newTile = addCoordinatesAndVector(intermediateTile, rotatedVector);\n\n  return newTile;\n};\n\nexport const chooseGhost2IntermediateTile = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const twoTilesAhead = moveFromTile(\n    pacMan.tileCoordinates,\n    pacMan.direction,\n    2\n  );\n  return pacMan.direction === 'UP'\n    ? moveFromTile(twoTilesAhead, 'LEFT', 2)\n    : twoTilesAhead;\n};\n\nconst chooseForGhost3InChaseState = (ghost: Ghost): TileCoordinates => {\n  const pacMan = ghost.game.pacMan;\n  const distance = getTileDistance(\n    ghost.tileCoordinates,\n    pacMan.tileCoordinates\n  );\n\n  return distance >= 8 ? pacMan.tileCoordinates : chooseInScatterMode(ghost);\n};\n\nconst choseInChaseMode = (ghost: Ghost): TileCoordinates => {\n  if (ghost.isInsideBoxWalls) {\n    return TILE_FOR_LEAVING_THE_BOX;\n  }\n  switch (ghost.ghostNumber) {\n    case 0:\n      return chooseForGhost0InChaseState(ghost);\n    case 1:\n      return chooseForGhost1InChaseState(ghost);\n    case 2:\n      return chooseForGhost2InChaseState(ghost);\n    case 3:\n      return chooseForGhost3InChaseState(ghost);\n    default:\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\n  }\n};\n\nconst getRandomInt = (max: number) =>\n  Math.floor(Math.random() * Math.floor(max));\n\nconst chooseInFrightenedMode = (ghost: Ghost): TileCoordinates => {\n  // Choose a random neighbour tile that is not backward and not into a wall.\n\n  return chooseSomeRandomMovement(ghost);\n};\n\n/**\n * Choose a random neighbour tile that is not backward and not into a wall.\n */\nconst chooseSomeRandomMovement = (ghost: Ghost): TileCoordinates => {\n  const candidateDirections: Direction[] = Directions.filter(\n    direction =>\n      direction !== ghost.direction &&\n      isWayFreeInDirection(ghost.tileCoordinates, direction)\n  );\n  assert(candidateDirections.length > 0);\n  const newDirection =\n    candidateDirections[getRandomInt(candidateDirections.length)];\n  assert(newDirection);\n  const randomNeighourTile = getNextTile(ghost.tileCoordinates, newDirection);\n\n  return randomNeighourTile;\n};\n\nconst chooseInDeadMode = (ghost: Ghost): TileCoordinates => {\n  // if (ghost.deadWaitingTimeInBoxLeft < 0) {\n  //   return chooseSomeRandomMovement(ghost);\n  // }\n  return TILE_FOR_RETURNING_TO_BOX;\n};\n","import { chooseNewTargetTile } from './chooseNewTargetTile';\nimport { chooseNextTile } from './chooseNextTile';\nimport {\n  TileCoordinates,\n  MAZE_WIDTH_IN_SCREEN_COORDINATES,\n  MAZE_HEIGHT_IN_SCREEN_COORDINATES,\n  assertValidTileCoordinates,\n} from './Coordinates';\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\nimport { Ghost } from './Ghost';\nimport { Direction } from './Types';\nimport { directionToVector } from './Ways';\nimport {\n  updateGhostStatePhaseTime,\n  updateGhostStatePhase,\n} from './updateGhostStatePhase';\nimport { Vector } from './Vector';\nimport { Game } from './Game';\nimport { action } from 'mobx';\n\nexport const updateGhosts = (game: Game) => {\n  for (const ghost of game.ghosts) {\n    updateGhost({ ghost });\n  }\n};\n\nconst updateGhost = ({ ghost }: { ghost: Ghost }) => {\n  if (ghost.ghostPaused) {\n    return;\n  }\n\n  updateGhostStatePhaseTime(ghost);\n  updateDeadWaitingTimeInBoxLeft(ghost);\n\n  updateGhostStatePhase(ghost);\n\n  routeAndMoveGhost(ghost);\n};\n\nconst updateDeadWaitingTimeInBoxLeft = (ghost: Ghost) => {\n  if (ghost.dead && ghost.deadWaitingTimeInBoxLeft > 0) {\n    ghost.deadWaitingTimeInBoxLeft -= ghost.game.lastFrameLength;\n  }\n};\n\nexport const routeAndMoveGhost = (ghost: Ghost) => {\n  if (ghost.game.pacMan.dead) {\n    return;\n  }\n\n  if (ghost.atTileCenter) {\n    reRouteGhost(ghost);\n  }\n\n  moveGhost(ghost);\n};\n\nconst reRouteGhost = (ghost: Ghost) => {\n  ghost.targetTile = chooseNewTargetTile(ghost);\n  updateDirection(ghost);\n  updateSpeed(ghost);\n};\n\nconst updateDirection = (ghost: Ghost) => {\n  const newDirection = getNewDirection(ghost);\n  ghost.direction = newDirection;\n};\n\nconst updateSpeed = (ghost: Ghost) => {\n  const newSpeedFactor = getNewSpeedFactor(ghost);\n  ghost.speedFactor = newSpeedFactor;\n};\n\nexport const getNewDirection = (ghost: Ghost): Direction => {\n  const currentTile = ghost.tileCoordinates;\n  const currentDirection = ghost.direction;\n  const targetTile = ghost.targetTile;\n  const boxDoorIsOpen = ghost.canPassThroughBoxDoor;\n\n  const nextTile: TileCoordinates = chooseNextTile({\n    currentTile,\n    currentDirection,\n    targetTile,\n    boxDoorIsOpen,\n  });\n\n  return getDirectionFromTileToTile(currentTile, nextTile);\n};\n\nconst moveGhost = (ghost: Ghost) => {\n  const vector: Vector = getGhostMovementVector(ghost);\n  moveGhostBy(ghost, vector);\n};\n\nconst moveGhostBy = action((ghost: Ghost, vector: Vector) => {\n  ghost.screenCoordinates.x =\n    (ghost.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  ghost.screenCoordinates.y =\n    (ghost.screenCoordinates.y + vector.y + MAZE_HEIGHT_IN_SCREEN_COORDINATES) %\n    MAZE_HEIGHT_IN_SCREEN_COORDINATES;\n\n  assertValidTileCoordinates(ghost.tileCoordinates);\n});\n\nconst isInTunnel = (tile: TileCoordinates) =>\n  tile.y === 14 && (tile.x >= 22 || tile.x <= 5);\n\nconst getGhostMovementVector = (ghost: Ghost): Vector => {\n  const speed = ghost.game.speed * ghost.speedFactor;\n  const velocity = directionToVector(ghost.direction, speed);\n  return velocity;\n};\n\nexport const SPEED_FACTOR_HIGH = 4;\nexport const SPEED_FACTOR_NORMAL = 2;\nexport const SPEED_FACTOR_SLOW = 0.5;\n\nconst getNewSpeedFactor = (ghost: Ghost): number => {\n  if (ghost.dead) {\n    return SPEED_FACTOR_HIGH;\n  }\n  if (isInTunnel(ghost.tileCoordinates) || ghost.state === 'frightened') {\n    return SPEED_FACTOR_SLOW;\n  }\n  return SPEED_FACTOR_NORMAL;\n};\n","import { MilliSeconds } from './Types';\nimport { PacMan } from './PacMan';\n\nexport type PacManDyingPhase = number;\nexport const PacManDyingPhaseCount = 13;\nexport const PacManDyingPhases: PacManDyingPhase[] = Array.from(\n  Array(PacManDyingPhaseCount).keys()\n);\nexport const PacManDyingPhaseLength: MilliSeconds = 200;\nexport const TotalPacManDyingAnimationLength: MilliSeconds =\n  PacManDyingPhaseLength * PacManDyingPhaseCount;\n\nexport const getPacManDyingPhase = (pacMan: PacMan): PacManDyingPhase => {\n  let dyingPhase: number = Math.floor(\n    pacMan.timeSinceDeath / PacManDyingPhaseLength\n  );\n\n  if (dyingPhase >= PacManDyingPhaseCount) {\n    dyingPhase = PacManDyingPhaseCount - 1;\n  }\n  return dyingPhase as PacManDyingPhase;\n};\n","import { action } from 'mobx';\nimport { MAZE_WIDTH_IN_SCREEN_COORDINATES } from './Coordinates';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport { Vector } from './Vector';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const movePacManBy = action((pacMan: PacMan, vector: Vector) => {\n  pacMan.screenCoordinates.x =\n    (pacMan.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\n  pacMan.screenCoordinates.y += vector.y;\n});\n","import { ScreenCoordinates, tileFromScreen } from './Coordinates';\nimport { Game } from './Game';\nimport { movePacManBy } from './movePacManBy';\nimport { PacMan } from './PacMan';\nimport { MilliSeconds } from './Types';\nimport {\n  directionToVector as directionAsVector,\n  isTileCenter,\n  isWayFreeInDirection,\n} from './Ways';\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\n\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\n\nexport const updatePacMan = (game: Game): void => {\n  const pacMan = game.pacMan;\n  if (pacMan.alive) {\n    updateLivingPacMan(pacMan);\n  } else {\n    updateDeadPacMan(pacMan);\n  }\n};\n\nconst updateLivingPacMan = (pacMan: PacMan) => {\n  if (isTileCenter(pacMan.screenCoordinates)) {\n    const tile = tileFromScreen(pacMan.screenCoordinates);\n\n    // Change direction if necessary\n    if (\n      pacMan.direction !== pacMan.nextDirection &&\n      isWayFreeInDirection(tile, pacMan.nextDirection)\n    ) {\n      pacMan.direction = pacMan.nextDirection;\n    }\n\n    // Move\n    if (isWayFreeInDirection(tile, pacMan.direction)) {\n      movePacMan(pacMan);\n    }\n  } else {\n    movePacMan(pacMan);\n  }\n};\n\nconst movePacMan = (pacMan: PacMan): void => {\n  const gameSpeed = pacMan.game.speed;\n  const speed = getPacManSpeed(gameSpeed);\n  const delta: ScreenCoordinates = directionAsVector(pacMan.direction, speed);\n  movePacManBy(pacMan, delta);\n};\n\nconst getPacManSpeed = (gameSpeed: number) => {\n  switch (gameSpeed) {\n    case 0.5:\n      return 1;\n    case 1:\n      return 2;\n    case 2:\n      return 4;\n    default:\n      return gameSpeed;\n  }\n};\n\nconst updateDeadPacMan = (pacMan: PacMan) => {\n  if (pacMan.timeSinceDeath >= TotalPacManDyingAnimationLength) {\n    revivePacMan(pacMan);\n  }\n  return;\n};\n\nconst revivePacMan = (pacMan: PacMan) => {\n  if (pacMan.extraLivesLeft > 0) {\n    pacMan.extraLivesLeft -= 1;\n    pacMan.game.revivePacMan();\n  }\n};\n","import { action } from 'mobx';\nimport { detectCollisions } from './detectCollisions';\nimport { Game } from './Game';\nimport { updateGhosts } from './updateGhosts';\nimport { updatePacMan } from './updatePacMan';\nimport { updateEnergizerTimer } from './updateEnergizerTimer';\nimport { updateExternalTimestamp } from './updateExternalTimeStamp';\nimport { updateGameTimestamp } from './updateGameTimestamp';\n\nexport const onAnimationFrame = action(\n  'onAnimationFrame',\n  ({ game, timestamp }: { game: Game; timestamp: number }) => {\n    updateExternalTimestamp({ game, externalTimeStamp: timestamp });\n\n    if (game.gamePaused) {\n      return;\n    }\n\n    updateGameTimestamp(game);\n    updateEnergizerTimer(game);\n    updatePacMan(game);\n    updateGhosts(game);\n    detectCollisions(game);\n  }\n);\n","import { Game } from './Game';\nimport { MilliSeconds } from './Types';\n\n// The typical duration of a frame: 1000ms for 60 frames per second = 17ms.\nexport const TYPICAL_FRAME_LENGTH: MilliSeconds = 17;\n\nexport const updateExternalTimestamp = ({\n  game,\n  externalTimeStamp,\n}: {\n  game: Game;\n  externalTimeStamp: number;\n}) => {\n  if (game.externalTimeStamp === null) {\n    // The very first frame\n    // We cannot measure its duration. Therefore we have to make an assumption.\n    game.lastFrameLength = TYPICAL_FRAME_LENGTH;\n  } else {\n    // A later frame.\n    // We can calculate its duration.\n    game.lastFrameLength = externalTimeStamp - game.externalTimeStamp;\n  }\n  game.externalTimeStamp = externalTimeStamp;\n};\n","import { Game } from './Game';\n\nexport const updateGameTimestamp = (game: Game) => {\n  game.timestamp += game.lastFrameLength;\n  game.frameCount++;\n};\n","import { Game } from './Game';\n\nexport const updateEnergizerTimer = (game: Game) => {\n  game.energizerTimer.advance(game.lastFrameLength);\n};\n","import { useStore } from '../components/StoreContext';\nimport { onAnimationFrame } from './onAnimationFrame';\nimport { useAnimationLoop } from './useAnimationLoop';\n\nexport const useGameLoop = () => {\n  const store = useStore();\n\n  const animationStep = (timestamp: number) => {\n    const { game } = store;\n    onAnimationFrame({ game, timestamp });\n  };\n\n  useAnimationLoop(animationStep);\n};\n","import { useEffect, useRef } from 'react';\nimport { MilliSeconds } from './Types';\n\ntype AnimationStepFunc = (timestamp: MilliSeconds) => void;\n\nexport const useAnimationLoop = (animationStep: AnimationStepFunc) => {\n  const requestRef = useRef(-1);\n\n  const animate = (timestamp: number) => {\n    animationStep(timestamp);\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestAnimationFrame(animate);\n    return () => {\n      cancelAnimationFrame(requestRef.current);\n    };\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\n  }, []);\n};\n","import styled from 'styled-components';\nimport { useStore } from '../../../components/StoreContext';\n\nexport const RestartView = () => {\n  const store = useStore();\n\n  const handleClick = () => {\n    store.resetGame();\n    store.game.gameStarted = true;\n  };\n  return <ButtonStyled onClick={handleClick}>Restart</ButtonStyled>;\n};\n\nconst ButtonStyled = styled.button`\n  min-width: 95px;\n  font-family: BoldPixel;\n  border: 3px solid #ffff00c7;\n  border-radius: 4px;\n  background: transparent;\n  color: #ffff00c7;\n  font-size: 16px;\n  height: auto;\n  cursor: pointer;\n  padding-top: 5px;\n  transition: all 0.2s ease-in-out;\n  :hover {\n    border-color: yellow;\n    color: yellow;\n  }\n`;\n","import { observer } from 'mobx-react-lite';\nimport { useGame } from '../../../components/StoreContext';\nimport './Score.css';\nimport classNames from 'classnames';\n\nexport const Score = observer<{ className?: string }>(({ className }) => {\n  const store = useGame();\n  return (\n    <div className={classNames('Score', className)}>\n      <span>Score</span>\n      <span>{store.score}</span>\n    </div>\n  );\n});\n","import { useStore } from '../../../components/StoreContext';\nimport styled from 'styled-components';\n\nexport const PauseView = () => {\n  const store = useStore();\n  const handleClick = () => {\n    store.game.gamePaused = !store.game.gamePaused;\n  };\n\n  return (\n    <ButtonStyled id=\"pacman-pause\" onClick={handleClick}>\n      Pause\n    </ButtonStyled>\n  );\n};\n\nconst ButtonStyled = styled.button`\n  min-width: 95px;\n  font-family: BoldPixel;\n  border: 3px solid #ffff00c7;\n  border-radius: 4px;\n  background: transparent;\n  color: #ffff00c7;\n  font-size: 16px;\n  height: auto;\n  padding-top: 5px;\n  cursor: pointer;\n  transition: all 0.2s ease-in-out;\n  :hover {\n    border-color: yellow;\n    color: yellow;\n  }\n`;\n","import styled from 'styled-components/macro';\n\nconst DEFAULT_SIZE = '8px';\n\nconst SIZE_MAPPING: { [key: string]: string } = {\n  small: '8px',\n  medium: '16px',\n  large: '24px',\n};\n\ntype Size = 'small' | 'middle' | 'large' | string;\nconst mappedSize = (size: Size): string => SIZE_MAPPING[size] ?? size;\n\nexport const HSpace = styled.div<{ size?: Size }>`\n  width: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n\nexport const VSpace = styled.div<{ size?: Size }>`\n  height: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\n`;\n","import React from 'react';\nimport './Board.css';\nimport classNames from 'classnames';\n\nexport const Board: React.FC<{ className?: string }> = ({\n  className,\n  children,\n}) => <div className={classNames('Board', className)}>{children}</div>;\n","import React, { FC, CSSProperties } from 'react';\nimport classNames from 'classnames';\nimport { SCALE_FACTOR } from '../model/Coordinates';\nimport './Sprite.css';\n\nconst scale = `scale(${SCALE_FACTOR})`;\n\nexport const Sprite: FC<{\n  name: string;\n  x: number;\n  y: number;\n  className?: string | null;\n  style?: CSSProperties;\n}> = ({ name: spriteName, x, y, className, style = {} }) => {\n  return (\n    <div\n      className={classNames('Sprite', 'Sprite-' + spriteName, className)}\n      style={{\n        ...style,\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`,\n        transform: scale,\n        transformOrigin: 'top left',\n      }}\n    />\n  );\n};\n","import React, { FC } from 'react';\nimport { Sprite } from '../../../components/Sprite';\n\nexport const MazeView: FC = () => (\n  <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\n);\n","import React, { FC } from 'react';\nimport { Rectangle } from '../model/Rectangle';\n\nexport const Box: FC<{ rect: Rectangle; color: string }> = ({\n  rect,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: rect.x,\n      top: rect.y,\n      width: rect.width,\n      height: rect.height,\n      backgroundColor: color,\n      zIndex: 1000,\n    }}\n  />\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC, memo } from 'react';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport {\n  addCoordinatesAndVector,\n  ScreenCoordinates,\n  screenFromTile,\n  SCREEN_TILE_CENTER_VECTOR,\n  TileCoordinates,\n} from '../../../model/Coordinates';\nimport { getPillHitBox } from '../../../model/detectCollisions';\nimport {\n  BASIC_PILL_ID,\n  ENERGIZER_ID,\n  MAZE_HEIGHT_IN_TILES,\n  MAZE_WIDTH_IN_TILES,\n  EMPTY_TILE_ID,\n} from '../../../model/MazeData';\nimport { useGame } from '../../../components/StoreContext';\n\nconst BasicPillView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"basic-pill\" />\n);\n\nconst EnergizerView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"energizer\" />\n);\n\nexport const BasicPillHitBox: FC = () => {\n  const rect = getPillHitBox({ x: 1, y: 3 }, BASIC_PILL_ID);\n  return <Box rect={rect} color=\"blue\" />;\n};\n\nconst PillView = observer<{ tile: TileCoordinates }>(\n  ({ tile }: { tile: TileCoordinates }) => {\n    const game = useGame();\n    const { x, y } = tile;\n    const tileId = game.maze.pills[y][x];\n    if (tileId === BASIC_PILL_ID) {\n      return (\n        <BasicPillView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    if (tileId === ENERGIZER_ID) {\n      return (\n        <EnergizerView\n          position={addCoordinatesAndVector(\n            screenFromTile(tile),\n            SCREEN_TILE_CENTER_VECTOR\n          )}\n        />\n      );\n    }\n    return null;\n  }\n);\n\n// Performance tricks used here:\n// Make each PillView an observer, so that we don't have to rerender PillsView.\n// Make PillsView a React.memo to prevent any rerenders.\n// Also: Create PillView only for those coordinates where there is a pill on first render.\nexport const PillsView: FC = memo(() => {\n  const game = useGame();\n\n  return (\n    <>\n      {Array.from({ length: MAZE_HEIGHT_IN_TILES }).map((_, y) =>\n        Array.from({ length: MAZE_WIDTH_IN_TILES }).map((_, x) => {\n          const pillFound = game.maze.pills[y][x] !== EMPTY_TILE_ID;\n          return pillFound && <PillView key={`${x}/${y}`} tile={{ x, y }} />;\n        })\n      )}\n    </>\n  );\n});\n\nPillsView.displayName = 'displayName';\n","import React, { FC, CSSProperties } from 'react';\nimport { Sprite } from '../../../components/Sprite';\nimport { Direction } from '../../../model/Types';\nimport { observer } from 'mobx-react-lite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { Box } from '../../../components/Box';\nimport { PacMan } from '../../../model/PacMan';\nimport { getPacManHitBox } from '../../../model/detectCollisions';\nimport {\n  PacManDyingPhase,\n  getPacManDyingPhase,\n} from '../../../model/pacManDyingPhase';\n\nexport type PacManAnimationPhase = 0 | 1 | 2;\n\nexport const PacManAnimationPhases: PacManAnimationPhase[] = [0, 1, 2];\n\nconst PAC_MAN_WIDTH = SCREEN_TILE_SIZE * 2;\nconst PAC_MAN_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst PAC_MAN_OFFSET_X = PAC_MAN_WIDTH / 2 - 2;\nconst PAC_MAN_OFFSET_Y = PAC_MAN_HEIGHT / 2 - 2;\n\nexport const PacManView: FC = observer(() => {\n  const store = useStore();\n  const game = useGame();\n  const pacMan = game.pacMan;\n  const { dead, alive, screenCoordinates, direction } = pacMan;\n  const { gameViewOptions } = store.debugState;\n  const pacManAnimationPhase = getPacManAnimationPhase(pacMan);\n  const dyingPhase = getPacManDyingPhase(pacMan);\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <PacManHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n        />\n      )}\n      {alive && (\n        <PacManSprite\n          direction={direction}\n          pacManAnimationPhase={pacManAnimationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n      {dead && (\n        <DyingPacManSprite\n          dyingPacManAnimationPhase={dyingPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\n        />\n      )}\n    </>\n  );\n});\n\nconst getPacManAnimationPhase = (pacMan: PacMan): PacManAnimationPhase => {\n  const step = Math.round(pacMan.game.timestamp / 200) % 4;\n  const phase = step === 3 ? 1 : step;\n  return phase as PacManAnimationPhase;\n};\n\nexport const PacManSprite: FC<{\n  direction: Direction;\n  pacManAnimationPhase: PacManAnimationPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ direction, pacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-pacman\"\n    name={`pacman-direction-${direction}-phase-${pacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const DyingPacManSprite: FC<{\n  dyingPacManAnimationPhase: PacManDyingPhase;\n  x: number;\n  y: number;\n  style?: CSSProperties;\n}> = ({ dyingPacManAnimationPhase, x, y, style }) => (\n  <Sprite\n    className=\"Sprite-dying-pacman\"\n    name={`dying-pacman-phase-${dyingPacManAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const PacManHitBox: FC<{ x: number; y: number }> = ({ x, y }) => {\n  const rect = getPacManHitBox({ x, y });\n  return <Box rect={rect} color=\"green\" />;\n};\n","import React from 'react';\nimport { ScreenCoordinates, SCREEN_TILE_SIZE } from '../../model/Coordinates';\nimport styled from 'styled-components/macro';\nimport { Direction } from '../../model/Types';\n\nconst x1 = 30;\nconst y1 = 30;\nconst x2 = 70;\nconst y2 = 70;\nconst x3 = 50;\nconst POINTS = `${x1},${y1} ${x2},${y1} ${x3},${y2} ${x1},${y1}`;\n\nconst DirectionToAngle = {\n  DOWN: 0,\n  LEFT: 90,\n  UP: 180,\n  RIGHT: 270,\n};\n\nexport const WayPoint: React.FC<{\n  screenCoordinates: ScreenCoordinates;\n  color: string;\n  direction: Direction;\n}> = ({ screenCoordinates, color, direction }) => {\n  const angle = DirectionToAngle[direction];\n  return (\n    <SvgStyled\n      viewBox=\"0 0 100 100\"\n      height=\"6\"\n      width=\"6\"\n      style={{\n        left: `${screenCoordinates.x + 1}px`,\n        top: `${screenCoordinates.y}px`,\n      }}\n    >\n      <g transform={`rotate(${angle} 50 50)`}>\n        <polygon points={POINTS} fill={color} stroke={color} strokeWidth={1} />\n      </g>\n    </SvgStyled>\n  );\n};\n\nconst SvgStyled = styled.svg`\n  position: absolute;\n  display: block;\n  width: ${SCREEN_TILE_SIZE}px;\n  height: ${SCREEN_TILE_SIZE}px;\n  pointer-events: none;\n`;\n","/* eslint-disable react/no-unescaped-entities */\nimport { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { screenFromTile, TileCoordinates } from '../../model/Coordinates';\nimport { WayPoint } from './WayPoint';\nimport { getDirectionFromTileToTile } from '../../model/getDirectionFromTileToTile';\nimport { Direction } from '../../model/Types';\nimport { assert } from '../../util/assert';\n\nexport const WayPoints = observer<{\n  wayPoints: TileCoordinates[];\n  color: string;\n}>(({ wayPoints, color }) => (\n  <>\n    {wayPoints.map((wayPoint, index) => {\n      const screenCoordinates = screenFromTile(wayPoint);\n      const direction = getDirection(wayPoints, index);\n      return (\n        <WayPoint\n          key={index}\n          screenCoordinates={screenCoordinates}\n          color={color}\n          direction={direction}\n        />\n      );\n    })}\n  </>\n));\n\nconst getDirection = (\n  wayPoints: TileCoordinates[],\n  index: number\n): Direction => {\n  if (wayPoints.length <= 1) {\n    return 'DOWN';\n  }\n  const indexToUse = index + 1 < wayPoints.length ? index : index - 1;\n  const fromTile = wayPoints[indexToUse];\n  const toTile = wayPoints[indexToUse + 1];\n  assert(toTile, `${indexToUse} ${wayPoints.length}`);\n  const direction = getDirectionFromTileToTile(fromTile, toTile);\n  return direction;\n};\n","import React, { FC } from 'react';\nimport {\n  TileCoordinates,\n  SCREEN_TILE_SIZE,\n  screenFromTileCoordinate,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\n\nconst SIZE = SCREEN_TILE_SIZE * 2;\nconst OFFSET = SCREEN_TILE_CENTER - SIZE / 2;\n\nexport const Target: FC<{ tile: TileCoordinates; color: string }> = ({\n  tile,\n  color,\n}) => (\n  <div\n    style={{\n      position: 'absolute',\n      left: screenFromTileCoordinate(tile.x) + OFFSET,\n      top: screenFromTileCoordinate(tile.y) + OFFSET,\n      width: SIZE,\n      height: SIZE,\n    }}\n  >\n    <svg version=\"1.1\" viewBox=\"0 0 22 22\">\n      <path\n        style={{ fill: color }}\n        transform={`rotate(45 11 11) translate(-550.29-608.65)`}\n        d=\"m559.29 611.65v1 5h-5-1v4h1 5v5 1h4v-1-5h6v-1-2-1h-1-5v-5-1z\"\n      />\n    </svg>\n  </div>\n);\n","import { observer } from 'mobx-react-lite';\nimport React, { FC } from 'react';\nimport {\n  SCREEN_TILE_SIZE,\n  SCREEN_TILE_CENTER,\n} from '../../../model/Coordinates';\nimport { getGhostHitBox } from '../../../model/detectCollisions';\nimport {\n  Ghost,\n  GhostAnimationPhase,\n  FrightenedGhostTime,\n} from '../../../model/Ghost';\nimport { Direction } from '../../../model/Types';\nimport { WayPoints } from '../../WayFindingPage/WayPoints';\nimport { Box } from '../../../components/Box';\nimport { Sprite } from '../../../components/Sprite';\nimport { useGame, useStore } from '../../../components/StoreContext';\nimport { Target } from './Target';\nimport { GhostViewOptions } from '../../../model/GhostViewOptions';\nimport { GameViewOptions } from '../../../model/GameViewOptions';\n\nconst GHOST_WIDTH = SCREEN_TILE_SIZE * 2;\nconst GHOST_HEIGHT = SCREEN_TILE_SIZE * 2;\n\nconst GHOST_OFFSET_X = GHOST_WIDTH / 2 - 0;\nconst GHOST_OFFSET_Y = GHOST_HEIGHT / 2;\n\nexport const GhostsGameView = observer(() => {\n  const store = useStore();\n  const { ghostViewOptions, gameViewOptions } = store.debugState;\n\n  return (\n    <GhostsView\n      ghostViewOptions={ghostViewOptions}\n      gameViewOptions={gameViewOptions}\n    />\n  );\n});\n\nexport const GhostsView: FC<{\n  ghostViewOptions?: GhostViewOptions;\n  gameViewOptions?: GameViewOptions;\n}> = observer(\n  ({\n    ghostViewOptions = DefaultGhostViewOptions,\n    gameViewOptions = DefaultGameViewOptions,\n  }) => {\n    const store = useGame();\n\n    return (\n      <>\n        {store.ghosts.map(ghost => (\n          <GhostCompositeView\n            key={ghost.ghostNumber}\n            ghost={ghost}\n            ghostViewOptions={ghostViewOptions}\n            gameViewOptions={gameViewOptions}\n          />\n        ))}\n      </>\n    );\n  }\n);\n\nconst DefaultGhostViewOptions: GhostViewOptions = {\n  target: false,\n  wayPoints: false,\n};\n\nconst DefaultGameViewOptions: GameViewOptions = {\n  hitBox: false,\n};\n\nexport const GhostCompositeView: FC<{\n  ghost: Ghost;\n  ghostViewOptions: GhostViewOptions;\n  gameViewOptions: GameViewOptions;\n}> = observer(({ ghost, ghostViewOptions, gameViewOptions }) => {\n  const { screenCoordinates } = ghost;\n  return (\n    <>\n      {gameViewOptions.hitBox && (\n        <GhostHitBox\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\n          color=\"green\"\n        />\n      )}\n      <GhostView ghost={ghost} />\n      {ghostViewOptions.wayPoints && (\n        <WayPoints wayPoints={ghost.wayPoints ?? []} color={ghost.colorCode} />\n      )}\n      {ghostViewOptions.target && (\n        <Target tile={ghost.targetTile} color={ghost.colorCode} />\n      )}\n    </>\n  );\n});\n\nexport const GhostView: FC<{\n  ghost: Ghost;\n}> = observer(({ ghost }) => {\n  const { screenCoordinates, animationPhase, direction, ghostNumber } = ghost;\n  // TODO\n  switch (ghost.state) {\n    case 'frightened':\n      return (\n        <FrightenedGhostSprite\n          frightenedGhostTime={ghost.frightenedGhostTime}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    case 'dead':\n      return (\n        <DeadGhostSprite\n          direction={direction}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n        />\n      );\n    default:\n      return (\n        <GhostSprite\n          direction={direction}\n          ghostAnimationPhase={animationPhase}\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\n          ghostNumber={ghostNumber}\n        />\n      );\n  }\n});\n\ntype GhostSpriteProps = {\n  direction: Direction;\n  ghostAnimationPhase: GhostAnimationPhase;\n  x: number;\n  y: number;\n  ghostNumber: number;\n  style?: { [key: string]: any };\n};\n\nexport const GhostSprite: FC<GhostSpriteProps> = ({\n  direction,\n  ghostAnimationPhase: phase,\n  x,\n  y,\n  ghostNumber,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`ghost-${ghostNumber}-direction-${direction}-phase-${phase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype DeadGhostSpriteProps = {\n  direction: Direction;\n  x: number;\n  y: number;\n  style?: { [key: string]: any };\n};\n\nexport const DeadGhostSprite: FC<DeadGhostSpriteProps> = ({\n  direction,\n  x,\n  y,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`dead-ghost-direction-${direction}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\ntype FrightenedGhostSpriteProps = {\n  x: number;\n  y: number;\n  ghostAnimationPhase: GhostAnimationPhase;\n  frightenedGhostTime: FrightenedGhostTime;\n  style?: { [key: string]: any };\n};\n\nexport const FrightenedGhostSprite: FC<FrightenedGhostSpriteProps> = ({\n  x,\n  y,\n  ghostAnimationPhase,\n  frightenedGhostTime,\n  style,\n}) => (\n  <Sprite\n    className=\"Sprite-ghost\"\n    name={`frightened-ghost-time-${frightenedGhostTime}-phase-${ghostAnimationPhase}`}\n    x={x}\n    y={y}\n    style={style}\n  />\n);\n\nexport const GhostHitBox: FC<{ x: number; y: number; color: string }> = ({\n  x,\n  y,\n  color,\n}) => {\n  const rect = getGhostHitBox({ x, y });\n  return <Box rect={rect} color={color} />;\n};\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport styled from 'styled-components/macro';\n\nexport const Message = observer<{ className?: string; text: string }>(\n  ({ className, text }) => {\n    return <MessageStyled className={className}>{text}</MessageStyled>;\n  }\n);\n\nconst MessageStyled = styled.span`\n  font-family: BoldPixel;\n  font-size: 24px;\n  color: yellow;\n  position: absolute;\n  left: 170px;\n  top: 332px;\n  width: 220px;\n  text-align: center;\n  padding-top: 5px;\n`;\n","import { observer } from 'mobx-react-lite';\nimport { FC } from 'react';\nimport './GameOver.css';\nimport { useGame } from '../../../components/StoreContext';\nimport { Message } from './Message';\nimport { TotalPacManDyingAnimationLength } from '../../../model/pacManDyingPhase';\nexport const TOTAL_TIME_TO_GAME_OVER_MESSAGE = TotalPacManDyingAnimationLength;\n\nexport const GameOver: FC<{ className?: string }> = observer(\n  ({ className }) => {\n    const game = useGame();\n    const { pacMan } = game;\n    const gameOverMessageVisible =\n      game.gameOver && pacMan.timeSinceDeath >= TOTAL_TIME_TO_GAME_OVER_MESSAGE;\n\n    return gameOverMessageVisible ? <Message text=\"Game Over\" /> : null;\n  }\n);\n","import { observer } from 'mobx-react-lite';\nimport React from 'react';\nimport { useGame } from '../../../components/StoreContext';\nimport classNames from 'classnames';\nimport styled from 'styled-components/macro';\nimport { PacManSprite } from './PacManView';\nimport { times } from 'lodash';\nimport { SCALE_FACTOR } from '../../../model/Coordinates';\n\nexport const ExtraLives = observer<{ className?: string }>(({ className }) => {\n  const game = useGame();\n  return (\n    <Layout className={classNames('ExtraLives', className)}>\n      <span>\n        {times(game.pacMan.extraLivesLeft, n => (\n          <PacManSprite\n            key={n}\n            direction=\"LEFT\"\n            pacManAnimationPhase={1}\n            x={n * 20 * SCALE_FACTOR}\n            y={0}\n          />\n        ))}\n      </span>\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  display: inline-flex;\n  position: relative;\n  width: calc(1 * 40px * var(--SCALE_FACTOR));\n  height: calc(16px * var(--SCALE_FACTOR));\n`;\n","import { useEffect, useLayoutEffect, useRef } from 'react'\n\nimport type { RefObject } from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\n// MediaQueryList Event based useEventListener interface\nfunction useEventListener<K extends keyof MediaQueryListEventMap>(\n  eventName: K,\n  handler: (event: MediaQueryListEventMap[K]) => void,\n  element: RefObject<MediaQueryList>,\n  options?: boolean | AddEventListenerOptions,\n): void\n\n// Window Event based useEventListener interface\nfunction useEventListener<K extends keyof WindowEventMap>(\n  eventName: K,\n  handler: (event: WindowEventMap[K]) => void,\n  element?: undefined,\n  options?: boolean | AddEventListenerOptions,\n): void\n\n// Element Event based useEventListener interface\nfunction useEventListener<\n  K extends keyof HTMLElementEventMap,\n  T extends HTMLElement = HTMLDivElement,\n>(\n  eventName: K,\n  handler: (event: HTMLElementEventMap[K]) => void,\n  element: RefObject<T>,\n  options?: boolean | AddEventListenerOptions,\n): void\n\n// Document Event based useEventListener interface\nfunction useEventListener<K extends keyof DocumentEventMap>(\n  eventName: K,\n  handler: (event: DocumentEventMap[K]) => void,\n  element: RefObject<Document>,\n  options?: boolean | AddEventListenerOptions,\n): void\n\n/**\n * Custom hook for attaching event listeners to DOM elements, the window, or media query lists.\n * @template KW - The type of event for window events.\n * @template KH - The type of event for HTML element events.\n * @template KM - The type of event for media query list events.\n * @template T - The type of the DOM element (default is `HTMLElement`).\n * @param {KW | KH | KM} eventName - The name of the event to listen for.\n * @param {(event: WindowEventMap[KW] | HTMLElementEventMap[KH] | MediaQueryListEventMap[KM] | Event) => void} handler - The event handler function.\n * @param {RefObject<T>} [element] - The DOM element or media query list to attach the event listener to (optional).\n * @param {boolean | AddEventListenerOptions} [options] - An options object that specifies characteristics about the event listener (optional).\n * @see [Documentation](https://usehooks-ts.com/react-hook/use-event-listener)\n * @example\n * // Example 1: Attach a window event listener\n * useEventListener('resize', handleResize);\n * @example\n * // Example 2: Attach a document event listener with options\n * const elementRef = useRef(document);\n * useEventListener('click', handleClick, elementRef, { capture: true });\n * @example\n * // Example 3: Attach an element event listener\n * const buttonRef = useRef<HTMLButtonElement>(null);\n * useEventListener('click', handleButtonClick, buttonRef);\n */\nfunction useEventListener<\n  KW extends keyof WindowEventMap,\n  KH extends keyof HTMLElementEventMap,\n  KM extends keyof MediaQueryListEventMap,\n  T extends HTMLElement | MediaQueryList = HTMLElement,\n>(\n  eventName: KW | KH | KM,\n  handler: (\n    event:\n      | WindowEventMap[KW]\n      | HTMLElementEventMap[KH]\n      | MediaQueryListEventMap[KM]\n      | Event,\n  ) => void,\n  element?: RefObject<T>,\n  options?: boolean | AddEventListenerOptions,\n) {\n  // Create a ref that stores handler\n  const savedHandler = useRef(handler)\n\n  useIsomorphicLayoutEffect(() => {\n    savedHandler.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    // Define the listening target\n    const targetElement: T | Window = element?.current ?? window\n\n    if (!(targetElement && targetElement.addEventListener)) return\n\n    // Create event listener that calls handler function stored in ref\n    const listener: typeof handler = event => {\n      savedHandler.current(event)\n    }\n\n    targetElement.addEventListener(eventName, listener, options)\n\n    // Remove event listener on cleanup\n    return () => {\n      targetElement.removeEventListener(eventName, listener, options)\n    }\n  }, [eventName, element, options])\n}\n\nexport { useEventListener }","import { useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { useStore } from '../../../components/StoreContext';\nimport { useOnClickOutside } from '../../../model/useOnClickOutside';\nimport { observer } from 'mobx-react-lite';\n\nconst options = [\n  { value: '0.5', label: 'Easy' },\n  { value: '1', label: 'Medium' },\n  { value: '2', label: 'Heavy' },\n];\n\nexport const LevelView = observer(() => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedOption, setSelectedOption] = useState(options[1]);\n  const ref = useRef(null);\n  const store = useStore();\n  useOnClickOutside(ref, () => setIsOpen(false));\n\n  const handleChange = (option: { value: string; label: string }) => {\n    store.level = Number(option.value);\n    store.resetGame();\n    setSelectedOption(option);\n    setIsOpen(false);\n  };\n\n  return (\n    <StyledDropdown ref={ref}>\n      <StyledDropdownControl\n        id=\"dropdown\"\n        isOpen={isOpen}\n        onClick={() => setIsOpen(prevIsOpen => !prevIsOpen)}\n      >\n        {selectedOption.label}\n      </StyledDropdownControl>\n      {isOpen && (\n        <StyledDropdownContent>\n          {options.map(item => (\n            <StyledDropdownItem\n              key={item.value}\n              onClick={() => handleChange(item)}\n            >\n              {item.label}\n            </StyledDropdownItem>\n          ))}\n        </StyledDropdownContent>\n      )}\n    </StyledDropdown>\n  );\n});\n\nconst StyledDropdown = styled.div`\n  position: relative;\n`;\n\nconst StyledDropdownContent = styled.div`\n  border: 3px solid white;\n  position: absolute;\n  top: 0;\n  background: black;\n  transform: translateY(-110%);\n  width: 100%;\n  border-radius: 4px;\n`;\n\nconst StyledDropdownControl = styled.button<{ isOpen: boolean }>`\n  font-family: BoldPixel;\n  background: black;\n  color: white;\n  font-size: 16px;\n  cursor: pointer;\n  padding-top: 5px;\n  border-radius: 4px;\n  display: flex;\n  min-width: 95px;\n  justify-content: center;\n  align-content: center;\n  opacity: ${({ isOpen }) => (isOpen ? '1' : '0.6')};\n  transition: all 0.2s ease-in-out;\n  border: 3px solid white;\n  cursor: pointer;\n  :hover {\n    opacity: 1;\n  }\n`;\n\nconst StyledDropdownItem = styled.button`\n  background: black;\n  border: none;\n  font-size: 14px;\n  padding: 4px;\n  font-family: BoldPixel;\n  width: 100%;\n  color: white;\n  opacity: 0.6;\n  transition: all 0.2s ease-in-out;\n  cursor: pointer;\n  :hover {\n    opacity: 1;\n  }\n`;\n","import { RefObject } from 'react';\nimport { useEventListener } from './useEventListener';\n\nexport function useOnClickOutside<T extends HTMLElement = HTMLElement>(\n  ref: RefObject<T> | RefObject<T>[],\n  handler: (event: MouseEvent | TouchEvent) => void,\n  eventType = 'mousedown'\n): void {\n  useEventListener(eventType as any, event => {\n    const target = event.target as Node;\n\n    // Do nothing if the target is not connected element with document\n    if (!target || !target.isConnected) {\n      return;\n    }\n\n    const isOutside = Array.isArray(ref)\n      ? ref.every(r => r.current && !r.current.contains(target))\n      : ref.current && !ref.current.contains(target);\n\n    if (isOutside) {\n      handler(event);\n    }\n  });\n}\n","export const SoundOff = ({ color = 'currentColor', width = 40 }) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"13.3 335.759 40 40\"\n    width={width}\n    fill={color}\n  >\n    <g>\n      <path d=\"M27.59 338.43h2.86v2.67h-2.86zM24.73 341.09h2.86v2.67h-2.86zM21.87 343.76h2.86v2.67h-2.86z\" />\n      <path d=\"M21.87 359.76v-13.34H13.3v18.68h8.58v-5.34zm-2.85-8v10.67h-2.86v-13.34h2.86v2.67zM39.01 349.09h2.86v2.67h-2.86zM50.44 349.09h2.86v2.67h-2.86zM41.87 351.76h2.86v2.67h-2.86zM47.58 351.76h2.86v2.67h-2.86z\" />\n      <path d=\"M21.87 365.09h2.86v2.67h-2.86zM44.73 354.43h2.86v2.67h-2.86zM24.73 367.76h2.86v2.67h-2.86zM41.87 357.09h2.86v2.67h-2.86z\" />\n      <path d=\"M47.58 357.09h2.86v2.67h-2.86zM27.59 370.43h2.86v2.67h-2.86zM39.01 359.76h2.86v2.67h-2.86zM50.44 359.76h2.86v2.67h-2.86z\" />\n      <path d=\"M30.44 335.76v2.67h2.86v34.66h-2.86v2.67h5.72v-40H33.3z\" />\n    </g>\n  </svg>\n);\n","export const SoundOn = ({ color = 'currentColor', width = 40 }) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width={width}\n    fill={color}\n    viewBox=\"13.3 170.213 40 40\"\n  >\n    <g>\n      <path d=\"M27.59 172.883h2.86v2.67h-2.86z\" />\n      <path d=\"M30.44 170.213v2.67h2.86v34.66h-2.86v2.67h5.72v-40H33.3zM50.44 172.883v34.66h2.86v-34.66zM24.73 175.543h2.86v2.67h-2.86zM21.87 178.213h2.86v2.67h-2.86zM44.73 180.883v21.33h2.85v-24h-2.85zM39.01 186.213v10.67h2.86v-13.34h-2.86z\" />\n      <path d=\"M21.87 194.213v-13.34H13.3v18.68h8.58v-5.34zm-2.85-8v10.67h-2.86v-13.34h2.86v2.67z\" />\n      <path d=\"M21.87 199.543h2.86v2.67h-2.86zM24.73 202.213h2.86v2.67h-2.86zM27.59 204.883h2.86v2.67h-2.86z\" />\n    </g>\n  </svg>\n);\n","import { useState } from 'react';\nimport styled from 'styled-components';\nimport { useStore } from '../../../components/StoreContext';\nimport { SoundOff } from '../../../components/SoundOff';\nimport { SoundOn } from '../../../components/SoundOn';\n\nexport const SoundView = () => {\n  const [isMuted, setIsMuted] = useState(\n    Boolean(localStorage.getItem('pacman-muted'))\n  );\n  const store = useStore();\n\n  const handleClick = () => {\n    store.muteSounds();\n    const muted = localStorage.getItem('pacman-muted');\n\n    if (muted !== 'true') {\n      setIsMuted(true);\n      localStorage.setItem('pacman-muted', 'true');\n    } else {\n      setIsMuted(false);\n      localStorage.removeItem('pacman-muted');\n    }\n  };\n  return (\n    <StyledButton onClick={handleClick}>\n      {isMuted ? <SoundOff width={20} /> : <SoundOn width={20} />}\n    </StyledButton>\n  );\n};\n\nconst StyledButton = styled.button`\n  background: black;\n  color: white;\n  cursor: pointer;\n  border-radius: 4px;\n  display: flex;\n  min-width: 95px;\n  justify-content: center;\n  align-items: center;\n  opacity: 0.6;\n  transition: all 0.2s ease-in-out;\n  border: 3px solid white;\n  padding: 3px;\n  cursor: pointer;\n  :hover {\n    opacity: 1;\n  }\n`;\n","import { useRef } from 'react';\nimport { useScaleElement } from '../../../model/useScaleElement';\nimport styled from 'styled-components';\nimport { RestartView } from './RestartView';\nimport { Row } from 'antd';\nimport { Score } from './Score';\nimport { PauseView } from './PauseView';\nimport { VSpace } from '../../../components/Spacer';\nimport { Board } from '../../../components/Board';\nimport { MazeView } from './MazeView';\nimport { PillsView } from './PillsView';\nimport { PacManView } from './PacManView';\nimport { GhostsGameView } from './GhostsView';\nimport { GameOver } from './GameOver';\nimport { ExtraLives } from './ExtraLives';\nimport { LevelView } from './LevelView';\nimport { SoundView } from './SoundView';\n\nexport const GameBoard = () => {\n  const contentRef = useRef<HTMLDivElement>(null);\n  const scale = useScaleElement({ contentRef });\n  return (\n    <Container\n      ref={contentRef}\n      style={{\n        transform: `scale(${scale})`,\n        transformOrigin: 'top center',\n      }}\n    >\n      <ScoreArea>\n        <RestartView />\n        <Row justify=\"center\">\n          <Score />\n        </Row>\n        <PauseView />\n      </ScoreArea>\n      <VSpace size=\"medium\" />\n      <BoardArea>\n        <Board>\n          <MazeView />\n          <PillsView />\n          <PacManView />\n          <GhostsGameView />\n          <GameOver />\n        </Board>\n        <VSpace size=\"medium\" />\n        <SettingsArea>\n          <SoundView />\n          <Row justify=\"center\">\n            <ExtraLives />\n          </Row>\n          <LevelView />\n        </SettingsArea>\n      </BoardArea>\n    </Container>\n  );\n};\n\nconst ScoreArea = styled.div`\n  display: flex;\n  justify-content: space-between;\n`;\n\nconst BoardArea = styled.div`\n  position: relative;\n`;\n\nconst Container = styled.div`\n  padding: 16px;\n`;\n\nconst SettingsArea = styled.div`\n  display: flex;\n  justify-content: space-between;\n`;\n","import React, { useState, useEffect } from 'react';\n\ninterface UseScaleElementProps {\n  contentRef: React.RefObject<HTMLDivElement>;\n}\n\nexport const useScaleElement = ({ contentRef }: UseScaleElementProps) => {\n  const [scale, setScale] = useState<number>(1);\n\n  const handleResize = () => {\n    const getContentWidth = (ref: React.RefObject<HTMLDivElement>) => {\n      return ref.current ? ref.current.scrollWidth : 0;\n    };\n\n    const getContentHeight = (ref: React.RefObject<HTMLDivElement>) => {\n      return ref.current ? ref.current.scrollHeight : 0;\n    };\n\n    const contentWidth = getContentWidth(contentRef);\n    const contentHeight = getContentHeight(contentRef);\n    const screenWidth = window.innerWidth;\n    const screenHeight = window.innerHeight;\n\n    // Determine scaling based on whether the content fits both width and height\n    const widthFit = screenWidth > contentWidth;\n    const heightFit = screenHeight > contentHeight;\n\n    let newScale = 1;\n    if (!widthFit && !heightFit) {\n      // If neither width nor height fit, scale down based on the smaller dimension\n      newScale = Math.min(\n        screenWidth / contentWidth,\n        screenHeight / contentHeight\n      );\n    } else if (!widthFit) {\n      // If only width doesn't fit, scale down based on the width\n      newScale = screenWidth / contentWidth;\n    } else if (!heightFit) {\n      // If only height doesn't fit, scale down based on the height\n      newScale = screenHeight / contentHeight;\n    }\n\n    setScale(newScale);\n  };\n\n  useEffect(() => {\n    // Initial scale on mount\n    handleResize();\n\n    // Add event listener for window resize\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      // Clean up the event listener on component unmount\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [contentRef]); // Re-run the effect when the contentRef changes\n\n  return scale;\n};\n","export default __webpack_public_path__ + \"static/media/ready.ad544456.mp3\";","import { observer } from 'mobx-react-lite';\nimport { useGame } from '../../../components/StoreContext';\nimport sound from '../../../resources/sfx/ready.mp3';\nimport { useEffect, useMemo } from 'react';\n\nexport const StartSound = observer(() => {\n  const game = useGame();\n  const startSound = useMemo(() => new Audio(sound), []);\n\n  useEffect(() => {\n    if (game.gameStarted) {\n      startSound\n        .play()\n        .then(() => {\n          startSound.volume = 0.5;\n        })\n        .catch(error => {\n          console.error('Failed to play start sound', error);\n        });\n    }\n    return () => {\n      startSound.pause();\n      startSound.src = ''; // Release the audio resource\n    };\n  }, [game.gameStarted, startSound]);\n\n  useEffect(() => {\n    if (game.gamePaused && startSound) {\n      startSound.pause();\n      startSound.src = '';\n    }\n  }, [game.gamePaused, startSound]);\n\n  useEffect(() => {\n    if (startSound) {\n      startSound.muted = game.isMuted;\n    }\n  }, [game.isMuted, startSound]);\n\n  return null;\n});\n","import { observer } from 'mobx-react-lite';\nimport React, { useState } from 'react';\nimport styled from 'styled-components/macro';\nimport { useStore } from '../../components/StoreContext';\nimport { useGameLoop } from '../../model/useGameLoop';\nimport { GameBoard } from './components/GameBoard';\nimport { useKeyboardActions } from './components/useKeyboardActions';\nimport { StartSound } from './components/StartSound';\n\nexport const GamePage: React.FC = observer(() => {\n  const [isStarted, setIsStarted] = useState(false);\n  const store = useStore();\n  useGameLoop();\n  useKeyboardActions();\n\n  const handleStart = () => {\n    store.resetGame();\n    setIsStarted(true);\n    store.game.gameStarted = true;\n  };\n\n  return (\n    <Layout data-testid=\"GamePage\">\n      {isStarted ? (\n        <>\n          <StartSound />\n          <GameBoard />\n        </>\n      ) : (\n        <Container>\n          <StartButton onClick={handleStart}>Start</StartButton>\n        </Container>\n      )}\n    </Layout>\n  );\n});\n\nconst Layout = styled.div`\n  display: grid;\n  grid-template-columns: 1fr;\n  justify-items: center;\n  align-items: center;\n`;\n\nconst StartButton = styled.button`\n  min-width: 95px;\n  font-family: BoldPixel;\n  border: 3px solid #ffff00c7;\n  border-radius: 4px;\n  background: transparent;\n  color: #ffff00c7;\n  font-size: 48px;\n  padding: 5px 20px 0;\n  height: auto;\n  cursor: pointer;\n  transition: all 0.2s ease-in-out;\n  :hover {\n    border-color: yellow;\n    color: yellow;\n  }\n`;\n\nconst Container = styled.div`\n  padding: 16px;\n`;\n","import { useCallback, useEffect } from 'react';\nimport { useStore } from '../../../components/StoreContext';\n\n/* eslint-disable  react-hooks/exhaustive-deps */\nexport const useKeyboardActions = (): void => {\n  const store = useStore();\n\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\n    const { game } = store;\n    const pressedKey = event.key;\n    const pacMan = game.pacMan;\n    switch (pressedKey) {\n      case 'ArrowLeft':\n        pacMan.nextDirection = 'LEFT';\n        break;\n      case 'ArrowRight':\n        pacMan.nextDirection = 'RIGHT';\n        break;\n      case 'ArrowUp':\n        pacMan.nextDirection = 'UP';\n        break;\n      case 'ArrowDown':\n        pacMan.nextDirection = 'DOWN';\n        break;\n      case ' ':\n        game.gamePaused = !game.gamePaused;\n        break;\n      default:\n        break;\n    }\n  }, []);\n\n  useEffect(() => {\n    document.addEventListener('keydown', onKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  }, []);\n};\n","import { FC, ComponentType } from 'react';\nimport 'antd/dist/antd.compact.css';\n\nimport './GlobalStyles.css';\nimport { Store } from './model/Store';\nimport { StoreProvider } from './components/StoreContext';\nimport { GamePage } from './pages/GamePage/GamePage';\n\nconst App: FC<{ store?: Store; Router?: ComponentType }> = ({\n  store = new Store(),\n}) => {\n  return (\n    <StoreProvider value={store}>\n      <div className=\"App\">\n        <GamePage />\n      </div>\n    </StoreProvider>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n// https://github.com/mobxjs/mobx-react-lite/tree/v2.0.5#observer-batching\nimport 'mobx-react-lite/batchingForReactDom';\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}